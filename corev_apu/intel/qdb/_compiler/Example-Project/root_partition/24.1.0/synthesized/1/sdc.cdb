22 serialization::archive 19 0 0 0 0 8 0 1 / 4 home 7 mustafa 8 projects 15 cva6_intel_fpga 4 cva6 9 corev_apu 5 intel 0 0 12 0 0 0 13 0 1 / 4 home 7 mustafa 8 projects 15 cva6_intel_fpga 4 cva6 9 corev_apu 5 intel 2 ip 18 ed_synth_emif_fm_0 23 altera_emif_arch_fm_191 5 synth 54 ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy.sdc 52485 # (C) 2001-2024 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file specifies the timing constraints of the memory device and
# of the memory interface

# ------------------------------------------- #
# -                                         - #
# --- Some useful functions and variables --- #
# -                                         - #
# ------------------------------------------- #

set script_dir [file dirname [info script]]
source "$script_dir/ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_ip_parameters.tcl"
source "$script_dir/ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_parameters.tcl"
source "$script_dir/ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_pin_map.tcl"

#--------------------------------------------#
# -                                        - #
# --- Determine when SDC is being loaded --- #
# -                                        - #
#--------------------------------------------#

set syn_flow 0
set sta_flow 0
set fit_flow 0
set pow_flow 0
if { $::TimeQuestInfo(nameofexecutable) == "quartus_map" || $::TimeQuestInfo(nameofexecutable) == "quartus_syn" } {
   set syn_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_sta" } {
   set sta_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_fit" } {
   set fit_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_pow" } {
   set pow_flow 1
}
set ::io_only_analysis 0

# ------------------------ #
# -                      - #
# --- GENERAL SETTINGS --- #
# -                      - #
# ------------------------ #

# This is a global setting and will apply to the whole design.
# This setting is required for the memory interface to be
# properly constrained.
derive_clock_uncertainty

# Debug switch. Change to 1 to get more run-time debug information
set debug 0

# All timing requirements will be represented in nanoseconds with up to 3 decimal places of precision
set_time_format -unit ns -decimal_places 3

# Determine if entity names are on
set entity_names_on [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_are_entity_names_on ]

# ---------------------- #
# -                    - #
# --- DERIVED TIMING --- #
# -                    - #
# ---------------------- #

# PLL multiplier to mem clk
regexp {([0-9\.]+) ps} $var(PLL_REF_CLK_FREQ_PS_STR) match var(PHY_REF_CLK_FREQ_PS)
regexp {([0-9\.]+) ps} $var(PLL_VCO_FREQ_PS_STR) match var(PHY_VCO_FREQ_PS)
set pll_multiplier [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_round_3dp [expr $var(PHY_MEM_CLK_FREQ_MHZ)/$var(PHY_REF_CLK_FREQ_MHZ)] ]
set vco_multiplier [expr int($var(PHY_REF_CLK_FREQ_PS)/$var(PHY_VCO_FREQ_PS))]

# Half of memory clock cycle
set half_period [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_round_3dp [ expr $var(UI) / 2.0 ] ]

# Half of reference clock
set ref_period      [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_round_3dp [ expr $var(PHY_REF_CLK_FREQ_PS)/1000.0] ]
set ref_half_period [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_round_3dp [ expr $ref_period / 2.0 ] ]

# Other clock periods
set tCK_AFI     [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_round_3dp [ expr 1000.0/$var(PHY_MEM_CLK_FREQ_MHZ)*$var(USER_CLK_RATIO) ] ]
set tCK_C2P_P2C [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_round_3dp [ expr 1000.0/$var(PHY_MEM_CLK_FREQ_MHZ)*$var(C2P_P2C_CLK_RATIO) ] ]
set tCK_PHY     [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_round_3dp [ expr 1000.0/$var(PHY_MEM_CLK_FREQ_MHZ)*$var(PHY_HMC_CLK_RATIO) ] ]

# Asymmetric uncertainties on address and command paths
set ac_min_delay [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_round_3dp [ expr - $var(tIH) + $var(CA_TO_CK_BD_PKG_SKEW) ]]
set ac_max_delay [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_round_3dp [ expr   $var(tIS) + $var(CA_TO_CK_BD_PKG_SKEW) ]]

# ---------------------- #
# -                    - #
# --- INTERFACE RATE --- #
# -                    - #
# ---------------------- #

# -------------------------------------------------------------------- #
# -                                                                  - #
# --- This is the main call to the netlist traversal routines      --- #
# --- that will automatically find all pins and registers required --- #
# --- to apply timing constraints.                                 --- #
# --- During the fitter, the routines will be called only once     --- #
# --- and cached data will be used in all subsequent calls.        --- #
# -                                                                  - #
# -------------------------------------------------------------------- #

if { ! [ info exists ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_sdc_cache ] } {
   ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_initialize_ddr_db ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_ddr_db var
   set ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_sdc_cache 1
} else {
   if { $debug } {
      post_message -type info "SDC: reusing cached DDR DB"
   }
}

# ------------------------------------------------------------- #
# -                                                           - #
# --- If multiple instances of this core are present in the --- #
# --- design they will all be constrained through the       --- #
# --- following loop                                        --- #
# -                                                           - #
# ------------------------------------------------------------- #

set instances [ array names ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_ddr_db ]
foreach { inst } $instances {
   if { [ info exists pins ] } {
      unset pins
   }
   array set pins $ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_ddr_db($inst)

   # ----------------------- #
   # -                     - #
   # --- REFERENCE CLOCK --- #
   # -                     - #
   # ----------------------- #

   # First determine if a reference clock has already been created (i.e. Reference clock sharing)
   set ref_clock_exists [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_does_ref_clk_exist $pins(pll_ref_clock) ]
   if { $ref_clock_exists == 0 }  {
      # This is the reference clock used by the PLL to derive any other clock in the core
      create_clock -period "$var(PHY_REF_CLK_FREQ_MHZ)MHz" -waveform [ list 0 $ref_half_period ] $pins(pll_ref_clock) -add -name ${inst}_ref_clock
   }
   set pins(ref_clock_name) [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_clock_name_from_pin_name $pins(pll_ref_clock)]

   # ------------------ #
   # -                - #
   # --- PLL CLOCKS --- #
   # -                - #
   # ------------------ #

   # VCO clock
   #We also detect and save the index of the clocks that drive the CPAs
   set is_master [expr {([string compare $inst $pins(master_instname)] == 0) ? 1 : 0}]
   set i_vco_clock 0
   set i_cpa_clock_tile_pri -1
   set i_cpa_clock_tile_sec -1
   foreach { vco_clock } $pins(pll_vco_clock) {

      set suffix "_${i_vco_clock}"
      if {$vco_clock == $pins(master_vco_clock)} {
         set suffix ""
         if {$is_master} {
            set i_cpa_clock_tile_pri $i_vco_clock
         }
      } elseif {$vco_clock == $pins(master_vco_clock_sec)} {
         if {$is_master} {
            set i_cpa_clock_tile_sec $i_vco_clock
         }
      }

      set local_pll_vco_clk_${i_vco_clock} [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_or_add_generated_clock \
         -target $vco_clock \
         -name "${inst}_vco_clk${suffix}" \
         -source $pins(pll_ref_clock) \
         -multiply_by [expr $vco_multiplier ]  \
         -divide_by 1 \
         -phase 0 ]
      incr i_vco_clock
   }
   
   if {! $var(IS_HPS)} {
      if {$is_master} {
         if {$i_cpa_clock_tile_pri == -1} {
            post_message -type critical_warning "Failed to find CPA clock index"
         }
         if {$i_cpa_clock_tile_sec == -1 && $var(PHY_PING_PONG_EN)} {
            post_message -type critical_warning "Failed to find CPA clock index for secondary interface"
         }
      }
   }

   # Core clocks
   set core_clocks [list]
   set core_clocks_local [list]

   # Skip if we're in HPS mode since there's no user accessible core clock
   # and there's no transfers within core fabric to analyze
   if {! $var(IS_HPS)} {

      set local_pll_master_vco_clock [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_or_add_generated_clock \
         -target $pins(master_vco_clock) \
         -name "${pins(master_instname)}_vco_clk" \
         -source $pins(pll_ref_clock) \
         -multiply_by [expr $vco_multiplier ]  \
         -divide_by 1 \
         -phase 0 ]

      # emif_usr_clk
      # Clock only exists when HMC is used.
      set local_core_usr_clock ""
      if {$pins(master_core_usr_clock) != ""} {
         set name "core_usr_clk"
         set master_core_clock $pins(master_core_usr_clock)
         set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO)}]
         set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

         set local_core_usr_clock [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_or_add_generated_clock \
            -target $master_core_clock \
            -name "${pins(master_instname)}_${name}" \
            -source $pins(master_vco_clock) \
            -multiply_by 1 \
            -divide_by $divide_by\
            -phase $phase ]

         lappend core_clocks $pins(master_core_usr_clock)
         lappend core_clocks_local $local_core_usr_clock 
      }
      
      # emif_usr_clk_sec
      # Clock only exists when ping-pong HMC is used
      set local_core_usr_clock_sec ""
      if {$pins(master_core_usr_clock_sec) != ""} {
         set name "core_usr_clk_sec"
         set master_core_clock_sec $pins(master_core_usr_clock_sec)
         set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO)}]
         set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

         set local_core_usr_clock_sec [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_or_add_generated_clock \
            -target $master_core_clock_sec \
            -name "${pins(master_instname)}_${name}" \
            -source $pins(master_vco_clock_sec) \
            -multiply_by 1 \
            -divide_by $divide_by\
            -phase $phase ]

         lappend core_clocks $pins(master_core_usr_clock_sec)
         lappend core_clocks_local $local_core_usr_clock_sec 
      }      

      # emif_usr_half_clk
      # Clock only exists when HMC is used and in 2x bridge mode
      set local_core_usr_half_clock ""
      if {$pins(master_core_usr_half_clock) != ""} {
         set name "core_usr_half_clk"
         set master_core_clock $pins(master_core_usr_half_clock)
         set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO) * 2}]
         set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

         set local_core_usr_half_clock [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_or_add_generated_clock \
            -target $master_core_clock \
            -name "${pins(master_instname)}_${name}" \
            -source $pins(master_vco_clock) \
            -multiply_by 1 \
            -divide_by $divide_by\
            -phase $phase ]

         lappend core_clocks $pins(master_core_usr_half_clock)
         lappend core_clocks_local $local_core_usr_half_clock
      }
      
      # emif_usr_half_clk
      # Clock only exists when ping-pong HMC is used and in 2x bridge mode
      set local_core_usr_half_clock_sec ""
      if {$pins(master_core_usr_half_clock_sec) != ""} {
         set name "core_usr_half_clk_sec"
         set master_core_clock_sec $pins(master_core_usr_half_clock_sec)
         set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO) * 2}]
         set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

         set local_core_usr_half_clock [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_or_add_generated_clock \
            -target $master_core_clock_sec \
            -name "${pins(master_instname)}_${name}" \
            -source $pins(master_vco_clock_sec) \
            -multiply_by 1 \
            -divide_by $divide_by\
            -phase $phase ]

         lappend core_clocks $pins(master_core_usr_half_clock_sec)
         lappend core_clocks_local $local_core_usr_half_clock
      }      

      # afi_clk
      # Clock only exists when HMC isn't used.
      set local_core_afi_clock ""
      if {$pins(master_core_afi_clock) != ""} {
         set name "core_afi_clk"
         set master_core_clock $pins(master_core_afi_clock)
         if {$var(USER_CLK_RATIO) == 8} {
            set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO) / 2}]
         } else {
            set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO)}]
         }
         set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

         set local_core_afi_clock [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_or_add_generated_clock \
            -target $master_core_clock \
            -name "${pins(master_instname)}_${name}" \
            -source $pins(master_vco_clock) \
            -multiply_by 1 \
            -divide_by $divide_by\
            -phase $phase ]

         lappend core_clocks $pins(master_core_afi_clock)
         lappend core_clocks_local $local_core_afi_clock
      }

      # extra CPA output for PE test purpose.
      set local_core_dft_cpa_1_clock "" 
      if {$pins(master_core_dft_cpa_1_clock) != ""} {
         set name "core_dft_cpa_1_clk"
         set master_core_clock $pins(master_core_dft_cpa_1_clock)
         set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO)}]
         set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

         set local_core_dft_cpa_1_clock [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_or_add_generated_clock \
            -target $master_core_clock \
            -name "${pins(master_instname)}_${name}" \
            -source $pins(master_vco_clock) \
            -multiply_by 1 \
            -divide_by $divide_by\
            -phase $phase ]

         lappend core_clocks $pins(master_core_dft_cpa_1_clock)
         lappend core_clocks_local $local_core_dft_cpa_1_clock
      }
      
      # Calibration master logic clock
      if {$pins(master_cal_master_clk) != ""} {
         set pll_cal_master_clk [get_pins -nowarn $pins(master_cal_master_clk)]

         if {[get_collection_size $pll_cal_master_clk] > 0} {
            set name              "core_cal_master_clk"
            set master_core_clock $pins(master_cal_master_clk)
            set divide_by         $var(pll_c4_cnt) 
            set phase             [expr { [lindex $var(PLL_C_CNT_PHASE_PS_STR_4) 0] * 360.0 / $var(PHY_VCO_FREQ_PS) / $var(pll_c4_cnt) } ]
            set duty_cyc          $var(PLL_C_CNT_DUTY_CYCLE_4)
            
            set local_cal_master_clock [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_or_add_generated_clock \
               -target $master_core_clock \
               -name "${pins(master_instname)}_${name}" \
               -source $pins(master_vco_clock) \
               -multiply_by 1  \
               -divide_by $divide_by  \
               -phase $phase \
               -duty_cycle $duty_cyc ]

            lappend core_clocks $pins(master_cal_master_clk)
            lappend core_clocks_local $local_cal_master_clock
         }
      }
      
      # Calibration slave logic clock
      if {$pins(master_cal_slave_clk) != ""} {
         set pll_cal_slave_clk [get_pins -nowarn $pins(master_cal_slave_clk)]

         if {[get_collection_size $pll_cal_slave_clk] > 0} {
            set name              "core_cal_slave_clk"
            set master_core_clock $pins(master_cal_slave_clk)
            set divide_by         $var(pll_c3_cnt) 
            set phase             [expr { [lindex $var(PLL_C_CNT_PHASE_PS_STR_3) 0] * 360.0 / $var(PHY_VCO_FREQ_PS) / $var(pll_c3_cnt) } ]
            set duty_cyc          $var(PLL_C_CNT_DUTY_CYCLE_3)
            
            set local_cal_slave_clock [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_or_add_generated_clock \
               -target $master_core_clock \
               -name "${pins(master_instname)}_${name}" \
               -source $pins(master_vco_clock) \
               -multiply_by 1  \
               -divide_by $divide_by  \
               -phase $phase \
               -duty_cycle $duty_cyc ]

            lappend core_clocks $pins(master_cal_slave_clk)
            lappend core_clocks_local $local_cal_slave_clock
         }
      }

      # Optional PLL Extra clocks
      for {set i_extra_clk 0} {$i_extra_clk < $var(PLL_NUM_OF_EXTRA_CLKS)} {incr i_extra_clk} {
         set pll_extra_clk [get_pins -nowarn $pins(pll_extra_clk_${i_extra_clk})]

         # PLL counter may not exist if clock isn't actually connected and used
         if {[get_collection_size $pll_extra_clk] > 0} {
            set i_clk_cnt_num     [expr {$i_extra_clk + $var(pll_num_of_reserved_cnts)}]
            set name              "core_extra_clk_${i_extra_clk}"
            set master_core_clock $pins(pll_extra_clk_${i_extra_clk})
            set divide_by         $var(pll_c${i_clk_cnt_num}_cnt)
            set phase             [expr { [lindex $var(PLL_C_CNT_PHASE_PS_STR_${i_clk_cnt_num}) 0] * 360.0 / $var(PHY_VCO_FREQ_PS) / $var(pll_c${i_clk_cnt_num}_cnt) } ]
            set duty_cyc          $var(PLL_C_CNT_DUTY_CYCLE_${i_clk_cnt_num})

            set local_pll_extra_clock [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_or_add_generated_clock \
               -target $master_core_clock \
               -name "${pins(master_instname)}_${name}" \
               -source $pins(master_vco_clock) \
               -multiply_by 1  \
               -divide_by $divide_by  \
               -phase $phase \
               -duty_cycle $duty_cyc ]
         }
      }
   }

   # Periphery clocks
   set periphery_clocks [list]
   set i_phy_clock 0
   foreach { phy_clock } $pins(pll_phy_clock) {
      set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(PHY_HMC_CLK_RATIO)}]
      set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

      set local_phy_clk_${i_phy_clock} [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_or_add_generated_clock \
         -target $phy_clock \
         -name "${inst}_phy_clk_${i_phy_clock}" \
         -source [lindex $pins(pll_vco_clock) $i_phy_clock] \
         -multiply_by 1 \
         -divide_by $divide_by \
         -phase $phase ]
      lappend periphery_clocks [set local_phy_clk_${i_phy_clock}]
      incr i_phy_clock
   }

   set i_phy_clock_l 0
   foreach { phy_clock_l } $pins(pll_phy_clock_l) {
      set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(C2P_P2C_CLK_RATIO)}]
      set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

      set local_phy_clk_l_${i_phy_clock_l} [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_or_add_generated_clock \
         -target $phy_clock_l \
         -name "${inst}_phy_clk_l_${i_phy_clock_l}" \
         -source [lindex $pins(pll_vco_clock) $i_phy_clock_l] \
         -multiply_by 1 \
         -divide_by $divide_by \
         -phase $phase ]
      lappend periphery_clocks [set local_phy_clk_l_${i_phy_clock_l}]
      incr i_phy_clock_l
   }

   # ------------------------ #
   # -                      - #
   # --- WRITE FIFO CLOCK --- #
   # -                      - #
   # ------------------------ #

   set write_fifo_clk [get_keepers ${inst}*|tile_gen[*].lane_gen[*].lane_inst|lane_inst~out_phy_reg]

   set i_wf_clock 0
   foreach_in_collection wf_clock $write_fifo_clk {
      set vco_clock_id [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_vco_clk_id $wf_clock var]
      if {$vco_clock_id == -1} {
         post_message -type critical_warning "Failed to find VCO clock"
      } else {
         set local_wf_clk_${i_wf_clock} [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_or_add_generated_clock \
           -target [get_node_info -name $wf_clock] \
           -name "${inst}_wf_clk_${i_wf_clock}" \
           -source [get_node_info -name $vco_clock_id] \
           -multiply_by 1 \
           -divide_by [expr $var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO)] \
           -phase 0 ]        
      }   
      incr i_wf_clock     
   }      

   # ---------------- #
   # -              - #
   # --- A/C PATH --- #
   # -              - #
   # ---------------- #

   # Only during the Fitter do we need to have constraints to allow for auto-delay chain code to
   # pick appropirate good settings
   # Also, only need it if address/command is not calibrated
   if {($fit_flow == 1) && ($var(CA_DESKEW) == 0)} {

      # First, define CK and CK#clocks because A/C timing is defined w.r.t. to these.
      set master_ck_clock ""
      foreach ac_clk_pin $pins(ac_clk) ac_clk_pin_n $pins(ac_clk_n) {
         set master_ck_clock [get_fanins $ac_clk_pin]
         foreach_in_collection check_pin $master_ck_clock {
            set check_pin_name [get_node_info -name $check_pin]
            if {[regexp {out_phy_reg$} $check_pin_name]} {
               set master_ck_clock $check_pin_name
               break
            }
         }
         create_generated_clock -multiply_by 1 -source $master_ck_clock $ac_clk_pin -name $ac_clk_pin     
         create_generated_clock -multiply_by 1 -invert -source $master_ck_clock $ac_clk_pin_n -name $ac_clk_pin_n     
      }
   
      foreach { ac_clk_pin } $pins(ac_clk) {
         # ac_pins can contain input ports such as mem_err_out_n
         # Loop through each ac pin to make sure we only apply set_output_delay to output ports
         foreach { ac_pin } $pins(ac_sync) {
            set ac_port [ get_ports $ac_pin ]
            if {[get_collection_size $ac_port] > 0} {
               if [ get_port_info -is_output_port $ac_port ] {
                  # Specifies the minimum delay difference between the DQS pin and the address/control pins:
                  set_output_delay -min $ac_min_delay -clock [get_clocks $ac_clk_pin] $ac_port -add_delay

                  # Specifies the maximum delay difference between the DQS pin and the address/control pins:
                  set_output_delay -max $ac_max_delay -clock [get_clocks $ac_clk_pin] $ac_port -add_delay
               }
            }
         }
      }
   } else {
      set_false_path -to $pins(ac_sync)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(ac_sync)
   }


   # ----------------- #
   # -               - #
   # --- READ PATH --- #
   # -               - #
   # ----------------- #

   foreach { read_clock } $pins(rclk) {
      create_clock -period "$var(PHY_MEM_CLK_FREQ_MHZ)MHz" -waveform [ list 0 $half_period ] $read_clock -name ${read_clock}_IN -add
   }

   # ------------------------------ #
   # -                            - #
   # --- MULTICYCLE CONSTRAINTS --- #
   # -                            - #
   # ------------------------------ #
   
   if {!$var(IS_HPS)} {

      # Relax timing to the input of the synchronizer for the local_reset_req signal
      # setup=7 and hold=6 are somewhat arbitrary choices
      if {$is_master} {
         set tmp "${inst}|arch|arch_inst|non_hps.core_clks_rsts_inst|local_reset_req_sync_gen_master.local_reset_req_sync_inst|din_s1"
         set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
         set tmp_reg [get_registers -nowarn $tmp]
         if {$fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
         } else {
            set_false_path -through $tmp_pin -to $tmp_reg
         }
      }

      # Soft reset synchronizers
      # See RTL for the justification of setup=7 and hold=6
      set tmp "${inst}|arch|arch_inst|non_hps.core_clks_rsts_inst|*reset_sync*"
      set tmp_pin [get_pins -nowarn ${inst}|arch|arch_inst|non_hps.core_clks_rsts_inst|*reset_sync*|clrn]
      set tmp_reg [get_registers -nowarn $tmp]
      if {[get_collection_size $tmp_pin] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp -hold 6 -end
         } else {
            set_false_path -through $tmp_pin -to $tmp_reg
         }
      }

      # seq2core_reset_done comes out of the PHY at up to 666MHz. Needs to be treated as async with synchronizer in the core.
      # setup=7 and hold=6 are somewhat arbitrary choices
      set tmp "${inst}|arch|arch_inst|seq_if_inst|non_hps.seq2core_reset_done_sync_inst|din_s1"
      set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
      set tmp_reg [get_registers -nowarn $tmp]
      if {[get_collection_size $tmp_pin] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
         } else {
            set_false_path -through $tmp_pin -to $tmp_reg
         }
      }      
      
      # ac_parity_err 
      # setup=7 and hold=6 are somewhat arbitrary choices
      set tmp "${inst}|arch|arch_inst|seq_if_inst|non_hps.seq2core_ac_parity_sync_inst|din_s1"
      set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
      set tmp_reg [get_registers -nowarn $tmp]
      if {[get_collection_size $tmp_pin] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
         } else {
            set_false_path -through $tmp_pin -to $tmp_reg
         }      
      }

      # afi_cal_in_progress (used by cal_counter module)
      # setup=7 and hold=6 are somewhat arbitrary choices
      set tmp "${inst}|arch|arch_inst|seq_if_inst|non_hps.afi_cal_in_progress_sync_inst|din_s1"
      set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
      set tmp_reg [get_registers -nowarn $tmp]
      if {[get_collection_size $tmp_pin] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
         } else {
            set_false_path -through $tmp_pin -to $tmp_reg
         }      
      }
      
      # afi_cal_success
      # setup=7 and hold=6 are somewhat arbitrary choices
      set tmp "${inst}|arch|arch_inst|seq_if_inst|non_hps.afi_cal_success_sync_inst|din_s1"
      set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
      set tmp_reg [get_registers -nowarn $tmp]
      if {[get_collection_size $tmp_pin] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
         } else {
            set_false_path -through $tmp_pin -to $tmp_reg
         }
      }      
      
      # afi_cal_fail
      # setup=7 and hold=6 are somewhat arbitrary choices
      set tmp "${inst}|arch|arch_inst|seq_if_inst|non_hps.afi_cal_fail_sync_inst|din_s1"
      set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
      set tmp_reg [get_registers -nowarn $tmp]
      if {[get_collection_size $tmp_pin] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
         } else {
            set_false_path -through $tmp_pin -to $tmp_reg
         }
      }      

      # cal_counter synchronizer for global_reset_n_int
      set tmp "${inst}|arch|arch_inst|cal_counter_inst|non_hps.inst_sync_reset_n|din_s1"
      set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
      set tmp_reg [get_registers -nowarn $tmp]
      if {[get_collection_size $tmp_pin] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
         } else {
            set_false_path -through $tmp_pin -to $tmp_reg
         }      
      }
      
      # cal_counter synchronizer for afi_cal_in_progress
      set tmp "${inst}|arch|arch_inst|cal_counter_inst|non_hps.inst_sync_cal_in_progress|din_s1"
      set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
      set tmp_reg [get_registers -nowarn $tmp]
      if {[get_collection_size $tmp_pin] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
         } else {
            set_false_path -through $tmp_pin -to $tmp_reg
         }
      }      

      set tmp [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_core2ctl[6]]
      if {[get_collection_size $tmp] > 0} {
         set_multicycle_path -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -through $tmp -from [get_keepers *reset*] -setup 3 -end
         set_multicycle_path -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -through $tmp -from [get_keepers *reset*] -hold  2 -end
      }

      if {$var(PHY_USERMODE_OCT)} {
         set tmp [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_ctl2core[19]]
         if {[get_collection_size $tmp] > 0} {
            set_multicycle_path -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_ctl2core[19] -to *gen_oct_cal_req.gen_oct_cal_req_no_hps.oct_cal_req_regs* -setup 4 -start
            set_multicycle_path -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_ctl2core[19] -to *gen_oct_cal_req.gen_oct_cal_req_no_hps.oct_cal_req_regs* -hold  3 -start
         }

         set tmp [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_core2ctl[7]]
         if {[get_collection_size $tmp] > 0} {
            set_multicycle_path -from ${inst}|arch|arch_inst|seq_if_inst|gen_oct_cal_rdy.gen_oct_cal_rdy_no_hps.oct_cal_rdy_regs|regs.sr_out* -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_core2ctl[7] -setup 4 -start
            set_multicycle_path -from ${inst}|arch|arch_inst|seq_if_inst|gen_oct_cal_rdy.gen_oct_cal_rdy_no_hps.oct_cal_rdy_regs|regs.sr_out* -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_core2ctl[7] -hold  3 -start
         }
      }

      set ufi_wr [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*ufi_write_reg]
      set ufi_rd [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*ufi_read_reg]

      if {([get_collection_size $ufi_wr] > 0) && ([get_collection_size $ufi_rd] > 0)} {
         set_multicycle_path -from $ufi_wr -to $ufi_rd -setup 1 -end
         set_multicycle_path -from $ufi_wr -to $ufi_rd -hold  1 -end
      }
   }

   if {$var(AMM_C2P_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*amm_c2p_ufi_i|*ufi_read_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -from $ufi_reg -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   if {$var(AMM_P2C_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*amm_p2c_ufi_i|*ufi_write_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -to $ufi_reg -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   if {$var(MMR_C2P_UFI_MODE)!= "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*mmr_c2p_ufi_i|*ufi_read_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -from $ufi_reg -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   if {$var(MMR_P2C_UFI_MODE)!= "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*mmr_p2c_ufi_i|*ufi_write_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -to $ufi_reg -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   if {$var(SEQ_C2P_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*seq_c2p_ufi_i|*ufi_read_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -from $ufi_reg -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*hmc_reg* -0.200
      }
   }
   if {$var(SEQ_P2C_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*seq_p2c_ufi_i|*ufi_write_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -to $ufi_reg -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*hmc_reg* -0.200
      }
   }
   if {$var(ECC_C2P_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*ecc_c2p_ufi_i|*ufi_read_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -from $ufi_reg -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   if {$var(ECC_P2C_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*ecc_p2c_ufi_i|*ufi_write_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -to $ufi_reg -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   if {$var(LANE_C2P_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*lane_c2p_ufi_i|*ufi_read_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -from $ufi_reg -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   if {$var(LANE_P2C_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*lane_p2c_ufi_i|*ufi_write_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -to $ufi_reg -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   if {$var(SIDEBAND_C2P_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*sideband_c2p_ufi_i|*ufi_read_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -from $ufi_reg -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   if {$var(SIDEBAND_P2C_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*sideband_p2c_ufi_i|*ufi_write_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -to $ufi_reg -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   
   foreach periphery_clock $periphery_clocks {
      set_clock_uncertainty -10ps -add -enable_same_physical_edge -hold -from [get_clocks $periphery_clock] -to [get_clocks $periphery_clock]
   }

   if {!$var(IS_HPS)} {
      set dll_reset [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst|lane_inst|core_dll[2]]
      if {[get_collection_size $dll_reset] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst|lane_inst|core_dll[2] -setup 8 -end
            set_multicycle_path -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst|lane_inst|core_dll[2] -hold  7 -end
         } else {
            set_false_path -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst|lane_inst|core_dll[2]
         }
      }
   }

   # ------------------------------ #
   # -                            - #
   # --- FALSE PATH CONSTRAINTS --- #
   # -                            - #
   # ------------------------------ #

   if {$var(C2C_TG_FALSE_PATH)} {
      set_false_path -from tg|tg|* -to tg|tg|*
   }   

   
   foreach ac_buf_path [concat $var(PATTERNS_AC_CLK) $var(PATTERNS_AC_SYNC) $var(PATTERNS_AC_ASYNC)] {
     set length [string length $ac_buf_path]
     set last_char [string range $ac_buf_path [expr $length -1] [expr $length -1]]
     
     if {[string equal $last_char "o"] == 1} {

        set word_idx [string first "cal_oct" $ac_buf_path]
        if {$word_idx == -1 } {
            set word_idx [string first "no_oct" $ac_buf_path]
            set suffix "no_oct.obuf"
        } else {
            set suffix "cal_oct.obuf"
        }
        set sub_path [string range $ac_buf_path 0 [expr {$word_idx - 1}]]

        set buf_path ${inst}|${sub_path}${suffix}
        set oe_path  "${buf_path}|oe"

        set_false_path -through $oe_path
        set_disable_timing -from oe -to o $buf_path
      }
   }


   foreach ac_n_buf_path $var(PATTERNS_AC_CLK_N) {
     set length [string length $ac_n_buf_path]
     set last_char [string range $ac_n_buf_path [expr $length -1] [expr $length -1]]
     
     if {[string equal $last_char "o"] == 1} {

        set word_idx [string first "cal_oct" $ac_n_buf_path]
        if {$word_idx == -1 } {
            set word_idx [string first "no_oct" $ac_n_buf_path]
            set suffix "no_oct.obuf_bar"
        } else {
            set suffix "cal_oct.obuf_bar"
        }
        set sub_path [string range $ac_n_buf_path 0 [expr {$word_idx - 1}]]

        set buf_path ${inst}|${sub_path}${suffix}
        set oe_path  "${buf_path}|oe"

        set_false_path -through $oe_path
        set_disable_timing -from oe -to o $buf_path
      }
   }


   foreach dqdqs_buf_path [concat $var(PATTERNS_WCLK) $var(PATTERNS_WDATA) $var(PATTERNS_DBI) $var(PATTERNS_DM)] {
     set length [string length $dqdqs_buf_path]
     set last_char [string range $dqdqs_buf_path [expr $length -1] [expr $length -1]]
     
     if {[string equal $last_char "o"] == 1} {
        set word_idx [string first "cal_oct" $dqdqs_buf_path]
        set suffix "cal_oct.obuf"
        
        set sub_path [string range $dqdqs_buf_path 0 [expr {$word_idx - 1}]]
        set buf_path ${inst}|${sub_path}${suffix}
        set oe_path  "${buf_path}|oe"
        set_false_path -through $oe_path
        set_disable_timing -from oe -to o $buf_path
      }
   } 

   foreach dqdqs_buf_path $var(PATTERNS_WCLK_N) {
     set length [string length $dqdqs_buf_path]
     set last_char [string range $dqdqs_buf_path [expr $length -1] [expr $length -1]]
     
     if {[string equal $last_char "o"] == 1} {
        set word_idx [string first "cal_oct" $dqdqs_buf_path]
        set suffix "cal_oct.obuf_bar"
        
        set sub_path [string range $dqdqs_buf_path 0 [expr {$word_idx - 1}]]
        set buf_path ${inst}|${sub_path}${suffix}
        set oe_path  "${buf_path}|oe"
        set_false_path -through $oe_path
        set_disable_timing -from oe -to o $buf_path
      }
   }

   # DQ/DQS pins are calibrated
   set_false_path -to $pins(wdata)
   set_false_path -from $pins(rdata)
   set_output_delay -clock $pins(ref_clock_name) 0 $pins(wdata)
   set_input_delay -clock $pins(ref_clock_name) 0 $pins(rdata)
   if {[llength $pins(dm)] > 0} {
      set_false_path -to $pins(dm)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(dm)
   }
   if {[llength $pins(dbi)] > 0} {
      set_false_path -to $pins(dbi)
      set_false_path -from $pins(dbi)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(dbi)
      set_input_delay -clock $pins(ref_clock_name) 0 $pins(dbi)
   }
   set_false_path -to $pins(wclk)
   set_output_delay -clock $pins(ref_clock_name) 0 $pins(wclk)
   if {[llength $pins(wclk_n)] > 0} {
      set_false_path -to $pins(wclk_n)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(wclk_n)
   }
   set_false_path -from $pins(rclk)
   if {[llength $pins(rclk_n)] > 0} {
      set_false_path -from $pins(rclk_n)
   }
   if {[llength $pins(ac_clk)] > 0} {
      set_false_path -to $pins(ac_clk)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(ac_clk) -add
   }
   if {[llength $pins(ac_clk_n)] > 0} {
      set_false_path -to $pins(ac_clk_n)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(ac_clk_n) -add
   }

   if {[llength $pins(ac_async)] > 0} {
      set_false_path -to $pins(ac_async)
      set_false_path -from $pins(ac_async)
      foreach ac_async $pins(ac_async) {
         if {[get_port_info -is_input $ac_async] || [get_port_info -is_inout $ac_async]} {
            set_input_delay -clock $pins(ref_clock_name) 0 $ac_async
         }
         if {[get_port_info -is_output $ac_async] || [get_port_info -is_inout $ac_async]} {
            set_output_delay -clock $pins(ref_clock_name) 0 $ac_async
         }
      }
   }
   
   if {!$var(IS_HPS)} {
      set tmp_pins_0 [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst|lane_inst|core2dbc_rd_data_rdy]
      set tmp_pins_1 [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst|lane_inst|dbc2core_rd_data_vld0]
      if {[get_collection_size $tmp_pins_0] > 0 && [get_collection_size $tmp_pins_1] > 0} {
         set_false_path -through $tmp_pins_0 -through $tmp_pins_1
      }
   }

   # ------------------------- #
   # -                       - #
   # --- CLOCK UNCERTAINTY --- #
   # -                       - #
   # ------------------------- #

   if {!$var(IS_HPS) && ($fit_flow == 1 || $sta_flow == 1)} {

      #################################
      # C2P/P2C transfers
      #################################

      # Get P2C / C2P Multi-tile clock uncertainty
      set p2c_c2p_multi_tile_clock_uncertainty [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_p2c_c2p_clock_uncertainty $inst var]

      # Get extra periphery clock uncertainty
      set periphery_clock_uncertainty [list]
      ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_periphery_clock_uncertainty periphery_clock_uncertainty var

      # Get Fitter overconstraints
      if {$fit_flow == 1} {
         ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_periphery_overconstraints periphery_overconstraints_st periphery_overconstraints_mt var
      } else {
         set periphery_overconstraints_st [list 0.0 0.0 0.0 0.0]
         set periphery_overconstraints_mt [list 0.0 0.0 0.0 0.0]
      }

      # Now loop over core/periphery clocks and set clock uncertainty
      set i_core_clock 0
      foreach core_clock $core_clocks {
         if {$core_clock != ""} {

            set local_core_clock [lindex $core_clocks_local $i_core_clock]
            
            if {$core_clock == $pins(master_core_usr_clock_sec) || $core_clock == $pins(master_core_usr_half_clock_sec)} {
               set same_tile_index $i_cpa_clock_tile_sec
            } else {
               set same_tile_index $i_cpa_clock_tile_pri
            }

            set i_phy_clock 0
            foreach { phy_clock } $pins(pll_phy_clock_l) {
               
               if {$i_phy_clock != $same_tile_index} {
                  # C2P/P2C where the periphery tile != CPA tile.
                  # For these transfers the SDC explicitly overrides the clock uncertainty values.
                  # Therefore, when overconstraining we must not use the "-add" option.
                  set add_to_derived ""
                  set c2p_su         [expr {$p2c_c2p_multi_tile_clock_uncertainty + [lindex $periphery_overconstraints_mt 0] + [lindex $periphery_clock_uncertainty 0]}]
                  set c2p_h          [expr {$p2c_c2p_multi_tile_clock_uncertainty + [lindex $periphery_overconstraints_mt 1] + [lindex $periphery_clock_uncertainty 1]}]
                  set p2c_su         [expr {$p2c_c2p_multi_tile_clock_uncertainty + [lindex $periphery_overconstraints_mt 2] + [lindex $periphery_clock_uncertainty 2]}]
                  set p2c_h          [expr {$p2c_c2p_multi_tile_clock_uncertainty + [lindex $periphery_overconstraints_mt 3] + [lindex $periphery_clock_uncertainty 3]}]
               } else {
                  # C2P/P2C where the periphery tile == CPA tile
                  # For these transfers it is safe to use the -add option since we rely on 
                  # derive_clock_uncertainty for the base value.
                  set add_to_derived "-add"
                  set c2p_su         [expr [lindex $periphery_overconstraints_st 0] + [lindex $periphery_clock_uncertainty 0]]
                  set c2p_h          [expr [lindex $periphery_overconstraints_st 1] + [lindex $periphery_clock_uncertainty 1]]
                  set p2c_su         [expr [lindex $periphery_overconstraints_st 2] + [lindex $periphery_clock_uncertainty 2]]
                  set p2c_h          [expr [lindex $periphery_overconstraints_st 3] + [lindex $periphery_clock_uncertainty 3]]
               }

               set catch_exception [catch {set local_phy_clk_l_${i_phy_clock}} result]
               if {$catch_exception == 0} {
                  set_clock_uncertainty -from [get_clocks $local_core_clock] -to   [get_clocks [set local_phy_clk_l_${i_phy_clock}]] -suppress_warnings -setup {*}$add_to_derived $c2p_su
                  set_clock_uncertainty -from [get_clocks $local_core_clock] -to   [get_clocks [set local_phy_clk_l_${i_phy_clock}]] -suppress_warnings -hold  {*}$add_to_derived $c2p_h
                  set_clock_uncertainty -to   [get_clocks $local_core_clock] -from [get_clocks [set local_phy_clk_l_${i_phy_clock}]] -suppress_warnings -setup {*}$add_to_derived $p2c_su
                  set_clock_uncertainty -to   [get_clocks $local_core_clock] -from [get_clocks [set local_phy_clk_l_${i_phy_clock}]] -suppress_warnings -hold  {*}$add_to_derived $p2c_h
                  
                  if {$sta_flow == 1 && $var(CUT_C2P_P2C_PATHS)} {
                     set_false_path -to [get_clocks [set local_phy_clk_l_${i_phy_clock}]] 
                     set_false_path -from [get_clocks [set local_phy_clk_l_${i_phy_clock}]] 
                  }
               }

               set catch_exception [catch {set local_phy_clk_${i_phy_clock}} result]
               if {$catch_exception == 0} {
                  set_clock_uncertainty -from [get_clocks $local_core_clock] -to   [get_clocks [set local_phy_clk_${i_phy_clock}]] -suppress_warnings -setup {*}$add_to_derived $c2p_su
                  set_clock_uncertainty -from [get_clocks $local_core_clock] -to   [get_clocks [set local_phy_clk_${i_phy_clock}]] -suppress_warnings -hold  {*}$add_to_derived $c2p_h
                  set_clock_uncertainty -to   [get_clocks $local_core_clock] -from [get_clocks [set local_phy_clk_${i_phy_clock}]] -suppress_warnings -setup {*}$add_to_derived $p2c_su
                  set_clock_uncertainty -to   [get_clocks $local_core_clock] -from [get_clocks [set local_phy_clk_${i_phy_clock}]] -suppress_warnings -hold  {*}$add_to_derived $p2c_h
                  
                  if {$sta_flow == 1 && $var(CUT_C2P_P2C_PATHS) } {
                     set_false_path -to [get_clocks [set local_phy_clk_${i_phy_clock}]] 
                     set_false_path -from [get_clocks [set local_phy_clk_${i_phy_clock}]] 
                  }
               
               }

               incr i_phy_clock
            }
         }
         incr i_core_clock
      }

      #################################
      # Within-core transfers
      #################################

      # Get extra core clock uncertainty
      set core_clock_uncertainty [list]
      ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_core_clock_uncertainty core_clock_uncertainty var

      # Get Fitter overconstraints
      if {$fit_flow == 1} {
         ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_core_overconstraints core_overconstraints var
      } else {
         set core_overconstraints [list 0.0 0.0 0.0 0.0]
      }

      set c2c_same_su         [expr [lindex $core_overconstraints 0] + [lindex $core_clock_uncertainty 0]]
      set c2c_same_h          [expr [lindex $core_overconstraints 1] + [lindex $core_clock_uncertainty 1]]
      set c2c_diff_su         [expr [lindex $core_overconstraints 2] + [lindex $core_clock_uncertainty 2]]
      set c2c_diff_h          [expr [lindex $core_overconstraints 3] + [lindex $core_clock_uncertainty 3]]

      # For these transfers it is safe to use the -add option of set_clock_uncertainty since
      # we rely on derive_clock_uncertainty for the base value.
      foreach src_core_clock_local $core_clocks_local {
         if {$src_core_clock_local != ""} {
            foreach dst_core_clock_local $core_clocks_local {
               if {$dst_core_clock_local != ""} {
                  if {$src_core_clock_local == $dst_core_clock_local} {
                     # Same clock network transfers
                     set_clock_uncertainty -from $src_core_clock_local -to $dst_core_clock_local -setup -add $c2c_same_su
                     set_clock_uncertainty -from $src_core_clock_local -to $dst_core_clock_local -hold -enable_same_physical_edge -add $c2c_same_h
                  } else {
                     # Transfers between different core clock networks
                     set_clock_uncertainty -from $src_core_clock_local -to $dst_core_clock_local -setup -add $c2c_diff_su
                     set_clock_uncertainty -from $src_core_clock_local -to $dst_core_clock_local -hold -add $c2c_diff_h
                  }
               }
            }
         }
      }

   }

   # --------------------- #
   # -                   - #
   # --- ACTIVE CLOCKS --- #
   # -                   - #
   # --------------------- #

   if {(($::quartus(nameofexecutable) ne "quartus_fit") && ($::quartus(nameofexecutable) ne "quartus_map"))} {

      if {$var(C2P_P2C_PR) && [llength $periphery_clocks] > 0 && !$debug} {
         post_sdc_message info "Setting periphery clocks as inactive; use Report DDR to timing analyze periphery clocks"
         set_active_clocks [remove_from_collection [get_active_clocks] [get_clocks $periphery_clocks]]
      }
   }
}

# -------------------------- #
# -                        - #
# --- REPORT DDR COMMAND --- #
# -                        - #
# -------------------------- #

add_ddr_report_command "source [list [file join [file dirname [info script]] ${::GLOBAL_ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_corename}_report_timing.tcl]]"

 13 0 1 / 4 home 7 mustafa 8 projects 15 cva6_intel_fpga 4 cva6 9 corev_apu 5 intel 2 ip 18 ed_synth_emif_fm_0 23 altera_emif_arch_fm_191 5 synth 68 ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_ip_parameters.tcl 39897 # (C) 2001-2024 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file specifies the timing properties of the memory device and
# of the memory interface

package require ::quartus::clock_uncertainty


set ::GLOBAL_ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_corename ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy

set var(PROTOCOL)                                                DDR4
set var(NUM_RANKS)                                               1
set var(SLEW_RATE_DRAM)                                          4.0
set var(SLEW_RATE_DRAM_CLOCK)                                    8.0
set var(VIN_Ms)                                                  0.13
set var(VIN_Mh)                                                  0.065
set var(SLEW_RATE_PHY)                                           2.0
set var(SLEW_RATE_PHY_CLOCK)                                     4.0
set var(SLEW_RATE_CA)                                            2.0
set var(SLEW_RATE_CLOCK)                                         4.0
set var(UI)                                                      0.833
set var(tCK)                                                     0.75
set var(tDQSQ)                                                   0.052500000000000005
set var(tQH)                                                     0.43
set var(tDS)                                                     0.04166666666666667
set var(tDH)                                                     0.04166666666666667
set var(tIS)                                                     0.062
set var(tIH)                                                     0.087
set var(tDQSCK)                                                  0.175
set var(tDQSS)                                                   0.27
set var(tWLS)                                                    0.108
set var(tWLH)                                                    0.108
set var(tDSS)                                                    0.18
set var(tDSH)                                                    0.18
set var(BD_PKG_SKEW)                                             0.02
set var(CA_BD_PKG_SKEW)                                          0.18
set var(CA_TO_CK_BD_PKG_SKEW)                                    0.0
set var(DQS_BOARD_SKEW)                                          0.02
set var(DQS_TO_CK_BOARD_SKEW)                                    0.02
set var(RD_ISI)                                                  0.12
set var(WR_ISI)                                                  0.13
set var(CA_ISI)                                                  0.15
set var(DQSG_ISI)                                                0.15
set var(WL_ISI)                                                  0.06
set var(X4)                                                      0
set var(IS_DLL_ON)                                               1
set var(OCT_RECAL)                                               1
set var(RDBI)                                                    1
set var(WDBI)                                                    1
set var(CUT_C2P_P2C_PATHS)                                       0
set var(CA_DESKEW)                                               1

set var(PHY_TARGET_SPEEDGRADE)                                   E2V
set var(PHY_TARGET_IS_ES)                                        false
set var(PHY_TARGET_IS_ES2)                                       false
set var(PHY_TARGET_IS_ES3)                                       true
set var(PHY_TARGET_IS_PRODUCTION)                                false
set var(PHY_CORE_CLKS_SHARING_ENUM)                              CORE_CLKS_SHARING_DISABLED
set var(PHY_CONFIG_ENUM)                                         CONFIG_PHY_AND_HARD_CTRL
set var(PHY_PING_PONG_EN)                                        false
set var(IS_HPS)                                                  false
set var(PHY_MEM_CLK_FREQ_MHZ)                                    1200.0
set var(PHY_REF_CLK_FREQ_MHZ)                                    33.333
set var(PHY_REF_CLK_JITTER_PS)                                   10.0
set var(PLL_REF_CLK_FREQ_PS_STR)                                 "30024 ps"
set var(PLL_VCO_FREQ_PS_STR)                                     "834 ps"
set var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO)                           1
set var(PLL_PHY_CLK_VCO_PHASE)                                   0
set var(USER_CLK_RATIO)                                          4
set var(C2P_P2C_CLK_RATIO)                                       4
set var(PHY_HMC_CLK_RATIO)                                       2
set var(MEM_FORMAT_ENUM)                                         MEM_FORMAT_RDIMM
set var(MEM_DATA_MASK_EN)                                        true
set var(DIAG_TIMING_REGTEST_MODE)                                false
set var(DIAG_CPA_OUT_1_EN)                                       false
set var(DIAG_USE_CPA_LOCK)                                       true
set var(PHY_USERMODE_OCT)                                        false
set var(AMM_C2P_UFI_MODE)                                        pin_ufi_use_in_direct_out_direct
set var(AMM_P2C_UFI_MODE)                                        pin_ufi_use_in_direct_out_direct
set var(MMR_C2P_UFI_MODE)                                        pin_ufi_use_in_direct_out_direct
set var(MMR_P2C_UFI_MODE)                                        pin_ufi_use_in_direct_out_direct
set var(SIDEBAND_C2P_UFI_MODE)                                   pin_ufi_use_in_direct_out_direct
set var(SIDEBAND_P2C_UFI_MODE)                                   pin_ufi_use_in_direct_out_direct
set var(SEQ_C2P_UFI_MODE)                                        pin_ufi_use_in_direct_out_direct
set var(SEQ_P2C_UFI_MODE)                                        pin_ufi_use_in_direct_out_direct
set var(ECC_C2P_UFI_MODE)                                        pin_ufi_use_in_direct_out_direct
set var(ECC_P2C_UFI_MODE)                                        pin_ufi_use_in_direct_out_direct
set var(LANE_C2P_UFI_MODE)                                       pin_ufi_use_in_direct_out_direct
set var(LANE_P2C_UFI_MODE)                                       pin_ufi_use_in_direct_out_direct
set var(PLL_NUM_OF_EXTRA_CLKS)                                   0
set var(PLL_C_CNT_LOW_3)                                         1
set var(PLL_C_CNT_HIGH_3)                                        1
set var(PLL_C_CNT_BYPASS_EN_3)                                   false
set var(PLL_C_CNT_PHASE_PS_STR_3)                                "0 ps"
set var(PLL_C_CNT_DUTY_CYCLE_3)                                  50
set var(PLL_C_CNT_LOW_4)                                         2
set var(PLL_C_CNT_HIGH_4)                                        2
set var(PLL_C_CNT_BYPASS_EN_4)                                   false
set var(PLL_C_CNT_PHASE_PS_STR_4)                                "0 ps"
set var(PLL_C_CNT_DUTY_CYCLE_4)                                  50
set var(PLL_C_CNT_LOW_5)                                         256
set var(PLL_C_CNT_HIGH_5)                                        256
set var(PLL_C_CNT_BYPASS_EN_5)                                   true
set var(PLL_C_CNT_PHASE_PS_STR_5)                                "0 ps"
set var(PLL_C_CNT_DUTY_CYCLE_5)                                  50
set var(PLL_C_CNT_LOW_6)                                         256
set var(PLL_C_CNT_HIGH_6)                                        256
set var(PLL_C_CNT_BYPASS_EN_6)                                   true
set var(PLL_C_CNT_PHASE_PS_STR_6)                                "0 ps"
set var(PLL_C_CNT_DUTY_CYCLE_6)                                  50
set var(PLL_C_CNT_LOW_7)                                         256
set var(PLL_C_CNT_HIGH_7)                                        256
set var(PLL_C_CNT_BYPASS_EN_7)                                   true
set var(PLL_C_CNT_PHASE_PS_STR_7)                                "0 ps"
set var(PLL_C_CNT_DUTY_CYCLE_7)                                  50
set var(PLL_C_CNT_LOW_8)                                         256
set var(PLL_C_CNT_HIGH_8)                                        256
set var(PLL_C_CNT_BYPASS_EN_8)                                   true
set var(PLL_C_CNT_PHASE_PS_STR_8)                                "0 ps"
set var(PLL_C_CNT_DUTY_CYCLE_8)                                  50

set var(C2P_SETUP_OC_NS)                                         0.000
set var(C2P_HOLD_OC_NS)                                          0.000
set var(P2C_SETUP_OC_NS)                                         0.000
set var(P2C_HOLD_OC_NS)                                          0.000
set var(C2C_SAME_CLK_SETUP_OC_NS)                                0.000
set var(C2C_SAME_CLK_HOLD_OC_NS)                                 0.000
set var(C2C_DIFF_CLK_SETUP_OC_NS)                                0.000
set var(C2C_DIFF_CLK_HOLD_OC_NS)                                 0.000
set var(C2C_TG_FALSE_PATH)                                       false
set var(C2P_P2C_PR)                                              false

set var(PATTERNS_AC_CLK)                                         [list arch|arch_inst|bufs_inst|gen_mem_ck.inst[0].b|cal_oct.obuf|o]
set var(PATTERNS_AC_CLK_N)                                       [list arch|arch_inst|bufs_inst|gen_mem_ck.inst[0].b|cal_oct.obuf_bar|o]
set var(PATTERNS_AC_SYNC)                                        [list arch|arch_inst|bufs_inst|gen_mem_a.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[2].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[3].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[4].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[5].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[6].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[7].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[8].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[9].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[10].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[11].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[12].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[13].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[14].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[15].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[16].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_act_n.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_ba.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_ba.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_bg.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_bg.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_cke.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_cs_n.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_odt.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_par.inst[0].b|cal_oct.obuf|o]
set var(PATTERNS_AC_ASYNC)                                       [list arch|arch_inst|bufs_inst|gen_mem_reset_n.inst[0].b|no_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_alert_n.inst[0].b|no_oct.ibuf|i]
set var(PATTERNS_RCLK)                                           [list arch|arch_inst|bufs_inst|gen_mem_dqs.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[2].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[3].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[4].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[5].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[6].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[7].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[8].b|cal_oct.obuf|o]
set var(PATTERNS_RCLK_N)                                         [list arch|arch_inst|bufs_inst|gen_mem_dqs.inst[0].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[1].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[2].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[3].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[4].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[5].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[6].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[7].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[8].b|cal_oct.obuf_bar|o]
set var(PATTERNS_WCLK)                                           [list arch|arch_inst|bufs_inst|gen_mem_dqs.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[2].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[3].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[4].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[5].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[6].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[7].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[8].b|cal_oct.obuf|o]
set var(PATTERNS_WCLK_N)                                         [list arch|arch_inst|bufs_inst|gen_mem_dqs.inst[0].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[1].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[2].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[3].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[4].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[5].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[6].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[7].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[8].b|cal_oct.obuf_bar|o]
set var(PATTERNS_RDATA)                                          [list arch|arch_inst|bufs_inst|gen_mem_dq.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[2].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[3].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[4].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[5].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[6].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[7].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[8].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[9].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[10].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[11].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[12].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[13].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[14].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[15].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[16].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[17].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[18].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[19].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[20].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[21].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[22].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[23].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[24].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[25].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[26].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[27].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[28].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[29].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[30].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[31].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[32].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[33].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[34].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[35].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[36].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[37].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[38].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[39].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[40].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[41].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[42].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[43].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[44].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[45].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[46].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[47].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[48].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[49].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[50].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[51].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[52].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[53].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[54].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[55].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[56].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[57].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[58].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[59].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[60].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[61].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[62].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[63].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[64].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[65].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[66].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[67].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[68].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[69].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[70].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[71].b|cal_oct.obuf|o]
set var(PATTERNS_WDATA)                                          [list arch|arch_inst|bufs_inst|gen_mem_dq.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[2].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[3].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[4].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[5].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[6].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[7].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[8].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[9].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[10].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[11].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[12].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[13].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[14].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[15].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[16].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[17].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[18].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[19].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[20].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[21].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[22].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[23].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[24].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[25].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[26].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[27].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[28].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[29].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[30].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[31].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[32].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[33].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[34].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[35].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[36].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[37].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[38].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[39].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[40].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[41].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[42].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[43].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[44].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[45].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[46].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[47].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[48].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[49].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[50].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[51].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[52].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[53].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[54].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[55].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[56].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[57].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[58].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[59].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[60].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[61].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[62].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[63].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[64].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[65].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[66].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[67].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[68].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[69].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[70].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[71].b|cal_oct.obuf|o]
set var(PATTERNS_DM)                                             [list ]
set var(PATTERNS_DBI)                                            [list arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[2].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[3].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[4].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[5].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[6].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[7].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[8].b|cal_oct.obuf|o]
set var(PATTERNS_ALERT_N)                                        [list arch|arch_inst|bufs_inst|gen_mem_alert_n.inst[0].b|no_oct.ibuf|i]

initialize_clock_uncertainty_data
 13 0 1 / 4 home 7 mustafa 8 projects 15 cva6_intel_fpga 4 cva6 9 corev_apu 5 intel 2 ip 18 ed_synth_emif_fm_0 23 altera_emif_arch_fm_191 5 synth 65 ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_parameters.tcl 1193 # (C) 2001-2024 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file specifies the timing properties of the memory device and
# of the memory interface
# Note - this file is no longer used and will be blank



 13 0 1 / 4 home 7 mustafa 8 projects 15 cva6_intel_fpga 4 cva6 9 corev_apu 5 intel 2 ip 18 ed_synth_emif_fm_0 23 altera_emif_arch_fm_191 5 synth 62 ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_pin_map.tcl 36262 # (C) 2001-2024 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


set script_dir [file dirname [info script]]
source "$script_dir/ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_utils.tcl"

load_package sdc_ext

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_ddr_pins { instname allpins var_array_name} {
   # We need to make a local copy of the allpins associative array
   upvar allpins pins
   upvar 1 $var_array_name var
   set debug 0

   set var(pll_inclock_search_depth) 30
   set var(pll_outclock_search_depth) 20
   set var(pll_vcoclock_search_depth) 5

   # ########################################
   #  1.0 find all of the PLL output clocks


   set pll_c0_periph_clock_pin_name     "lvds_clk\[0\]"
   set pll_c1_periph_clock_pin_name     "loaden\[0\]"
   set vco_clock_pin_name               "vcoph\[0\]"

   #  C0 output in the periphery
   set pins(pll_c0_periph_clock) [list]
   set pins(pll_c0_periph_clock_pin_id) [get_pins -nowarn [list ${instname}|arch|arch_inst|pll_inst|pll_inst*|$pll_c0_periph_clock_pin_name]]

   foreach_in_collection c $pins(pll_c0_periph_clock_pin_id) {
      set pin_info [get_pin_info -net $c]
      set net_name [get_net_info -name $pin_info]

      if {$debug} {
         puts "PLL pin -> PLL Net: [get_node_info -name $c] -> $net_name"
      }
      lappend pins(pll_c0_periph_clock) [regsub -all {\\} $net_name {\\\\}]
   }
   set pins(pll_c0_periph_clock) [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_sort_duplicate_names $pins(pll_c0_periph_clock)]

   #  C1 output in the periphery
   set pins(pll_c1_periph_clock) [list]
   set pins(pll_c1_periph_clock_pin_id) [get_pins -nowarn [list ${instname}|arch|arch_inst|pll_inst|pll_inst*|$pll_c1_periph_clock_pin_name]]

   foreach_in_collection c $pins(pll_c1_periph_clock_pin_id) {
      set pin_info [get_pin_info -net $c]
      set net_name [get_net_info -name $pin_info]

      if {$debug} {
         puts "PLL pin -> PLL Net: [get_node_info -name $c] -> $net_name"
      }

      lappend pins(pll_c1_periph_clock) [regsub -all {\\} $net_name {\\\\}]
   }
   set pins(pll_c1_periph_clock) [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_sort_duplicate_names $pins(pll_c1_periph_clock)]

   #  VCO clock (used for the system clock)
   set pins(vco_clock) [list]
   set pins(vco_clock_pin_id) [get_pins -nowarn [list ${instname}|arch|arch_inst|pll_inst|pll_inst*|$vco_clock_pin_name]]

   foreach_in_collection c $pins(vco_clock_pin_id) {
      set pin_info [get_pin_info -net $c]
      set net_name [get_net_info -name $pin_info]

      if {$debug} {
         puts "PLL pin -> PLL Net: [get_node_info -name $c] -> $net_name"
      }

      lappend pins(vco_clock) [regsub -all {\\} $net_name {\\\\}]
   }
   set pins(vco_clock) [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_sort_duplicate_names $pins(vco_clock)]
   set pins(pll_vco_clock) $pins(vco_clock)
   set pins(pll_phy_clock) $pins(pll_c1_periph_clock)
   set pins(pll_phy_clock_l) $pins(pll_c0_periph_clock)

   if {$debug == 1} {
     puts "VCO:           $pins(pll_vco_clock)"
     puts "PHY:           $pins(pll_phy_clock)"
     puts "PHY_L:         $pins(pll_phy_clock_l)"
     puts ""
   }

   #########################################
   # 2.0  Find the actual master core clock
   #      As it could come from another interface
   #      In master/slave configurations
   #
   # Skip this if we're in HPS mode as core clocks don't exist
   
   set pins(master_vco_clock) ""
   set pins(master_vco_clock_sec) ""
   set pins(master_core_usr_clock) ""
   set pins(master_core_usr_half_clock) ""
   set pins(master_core_usr_clock_sec) ""
   set pins(master_core_usr_half_clock_sec) ""
   set pins(master_core_afi_clock) ""
   set pins(master_core_dft_cpa_1_clock) ""
   set pins(master_cal_master_clk) ""
   set pins(master_cal_slave_clk) ""
   
   if {$var(IS_HPS)} {
      set pins(master_instname) $instname

   } else {
      set msg_list [ list ]

      set num_of_cpa_blocks [expr {$var(PHY_PING_PONG_EN) ? 2 : 1}]

      for {set cpa_idx 0} {$cpa_idx < $num_of_cpa_blocks} {incr cpa_idx} {

         if {$cpa_idx == 0} {
            set sync_reset_reg ${instname}|arch|arch_inst|non_hps.core_clks_rsts_inst|reset_sync_pri_sdc_anchor
         } else {
            set sync_reset_reg ${instname}|arch|arch_inst|non_hps.core_clks_rsts_inst|pp.reset_sync_sec_sdc_anchor
         }

         set core_reset_sync_clock "_UNDEFINED_PIN_"
         set core_reset_sync_clock_id [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_output_clock_id $sync_reset_reg "Usr clock" msg_list var]
         if {$core_reset_sync_clock_id == -1} {
            foreach {msg_type msg} $msg_list {
               post_message -type $msg_type "ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_pin_map.tcl: $msg"
            }
            post_message -type error "ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_pin_map.tcl: Failed to find clock source for register $sync_reset_reg"

            if {$var(PHY_CORE_CLKS_SHARING_ENUM) == "CORE_CLKS_SHARING_SLAVE"} {
               post_message -type error "ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_pin_map.tcl: This is a clock sharing SLAVE interface. Please ensure that the clks_sharing_master_out port of the master is connected to the clks_sharing_master_in port of the slave(s)."
               if {$cpa_idx > 0} {
                  post_message -type error "ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_pin_map.tcl: This clock sharing slave interface uses a Ping-Pong PHY and has extra clock/reset requirements. Please ensure that the master interface is also a ping-pong interface. A ping-pong interface can act as clock sharing master for both ping-pong and non-ping-pong interfaces."
               }
            } else {
               post_message -type error "ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_pin_map.tcl: Please ensure that the register has not been removed or optimized away."
            }
         } else {
            set core_reset_sync_clock [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_pll_clock_name $core_reset_sync_clock_id]
         }

         if {[regexp {(^.*)\|arch\|arch_inst\|io_tiles_wrap_inst\|io_tiles_inst\|tile_gen\[([0-9])\].tile_ctrl_inst(.*)\|pa_core_clk_out\[[0-9]\]$} $core_reset_sync_clock matched pins(master_instname) tilegen_num tile_instnum] == 1} {
            if {$var(PHY_CONFIG_ENUM) == "CONFIG_PHY_AND_HARD_CTRL"} {
               if {$var(USER_CLK_RATIO) == 2 && $var(C2P_P2C_CLK_RATIO) == 4} {
                  if {$cpa_idx == 0} {
                     set pins(master_core_usr_clock)          "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[0\]"
                     set pins(master_core_usr_half_clock)     "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[1\]"
                  } else {
                     set pins(master_core_usr_clock_sec)      "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[0\]"
                     set pins(master_core_usr_half_clock_sec) "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[1\]"
                  }
               } else {
                  if {$cpa_idx == 0} {
                     set pins(master_core_usr_clock)          "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[0\]"
                  } else {
                     set pins(master_core_usr_clock_sec)      "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[0\]"
                  }
               }
               set pins(master_core_dft_cpa_1_clock)   [expr {$var(DIAG_CPA_OUT_1_EN) ? "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[1\]" : ""}]

            } else {
               set pins(master_core_afi_clock)             "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[0\]"
            }

            if { $::TimeQuestInfo(nameofexecutable) == "quartus_map" || $::TimeQuestInfo(nameofexecutable) == "quartus_syn"} {
               set vco_clock_name "_UNDEFINED_PIN_"
            } else {
               set vco_clock_id [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_vco_clk_id $core_reset_sync_clock_id var]
               set vco_clock_name [get_net_info -name [get_pin_info -net $vco_clock_id]]
            }
            if {$cpa_idx == 0} {
               set pins(master_vco_clock) $vco_clock_name
            } else {
               set pins(master_vco_clock_sec) $vco_clock_name
            }

         } else {
            post_message -type error "ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_pin_map.tcl: Failed to find CPA outputs."
         }
      }

      if {!$var(DIAG_USE_CPA_LOCK)} {
         set pins(counter_lock_reg) $pins(master_instname)|arch|arch_inst|non_hps.core_clks_rsts_inst|counter_lock
      }

      set pll_master_user_clock_base [string range $pins(master_vco_clock) 0 [string last "|" $pins(master_vco_clock)] ]pll_inst|outclk

      set var(pll_c3_cnt) [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_calculate_counter_value $var(PLL_C_CNT_HIGH_3) $var(PLL_C_CNT_LOW_3) $var(PLL_C_CNT_BYPASS_EN_3)]
      set pins(master_cal_slave_clk) "$pll_master_user_clock_base\[3\]"

      set var(pll_c4_cnt) [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_calculate_counter_value $var(PLL_C_CNT_HIGH_4) $var(PLL_C_CNT_LOW_4) $var(PLL_C_CNT_BYPASS_EN_4)]
      set pins(master_cal_master_clk) "$pll_master_user_clock_base\[4\]"
   }

   if {$debug == 1} {
     puts "Master VCO                       : $pins(master_vco_clock)"
     puts "Master Core USR                  : $pins(master_core_usr_clock)"
     puts "Master Core USR Half             : $pins(master_core_usr_half_clock)"
     puts "Master Core AFI                  : $pins(master_core_afi_clock)"
     puts "Master VCO (SECONDARY)           : $pins(master_vco_clock_sec)"
     puts "Master Core USR (SECONDARY)      : $pins(master_core_usr_clock_sec)"
     puts "Master Core USR Half (SECONDARY) : $pins(master_core_usr_half_clock_sec)"
     puts ""
   }

   # ########################################
   #  2.5 Find the reference clock input of the PLL

   set pins(pll_cascade_in_id) [get_pins -nowarn -compatibility_mode $pins(master_instname)|arch|arch_inst|pll_inst|pll_inst|pll_cascade_in]
   if {[get_collection_size $pins(pll_cascade_in_id)] == 0} {
      set pins(pll_cascade_in_id) [get_pins -compatibility_mode $pins(master_instname)|arch|arch_inst|pll_inst|pll_inst|core_refclk]
   }
   set pll_ref_clock_id [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_input_clk_id $pins(pll_cascade_in_id) var]
   if {$pll_ref_clock_id == -1} {
      post_message -type critical_warning "ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_pin_map.tcl: Failed to find PLL reference clock"
   } else {
      set pll_ref_clock [get_node_info -name $pll_ref_clock_id]
   }
   set pins(pll_ref_clock) $pll_ref_clock

   if {$debug == 1} {
     puts "REF:     $pins(pll_ref_clock)"
     puts ""
   }

   #########################################
   # 3.0  find the FPGA pins

   # The hierarchy paths to all the pins are stored in the *_ip_parameters.tcl
   # file which is a generated file. Pins are divided into the following
   # protocol-agnostic categories. For each pin category, we need to
   # fully-resolve the hierarchy path patterns and store the results into
   # the "pins" arrays.

   set pin_categories [list ac_clk \
                            ac_clk_n \
                            ac_sync \
                            ac_async \
                            rclk \
                            rclk_n \
                            wclk \
                            wclk_n \
                            rdata \
                            wdata \
                            dm \
                            dbi ]

   set patterns [ list ]
   foreach pin_category $pin_categories {
      set pins($pin_category) [list]

      foreach pattern $var(PATTERNS_[string toupper $pin_category]) {
         set pattern "${instname}|$pattern"
         lappend patterns $pin_category $pattern
      }
   }

   foreach {pin_type pattern} $patterns {
      if {[string match "*|o" $pattern]} {
         set local_pins [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_names_in_collection [ get_fanouts $pattern ] ]
      } else {
         set local_pins [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_names_in_collection [ get_fanins $pattern ] ]
      }

      if {[llength $local_pins] == 0} {
         post_message -type critical_warning "Could not find pin of type $pin_type from pattern $pattern"
      } else {
         foreach pin [lsort -unique $local_pins] {
            lappend pins($pin_type) $pin
         }
      }
   }


   #########################################
   # 4.0  setup extra PLL clocks parameters

   # User can use remaining PLL clocks from EMIF GUI and this is to
   # setup the parameters for those clocks such as multiply_by
   # and divide_by

   if {$var(PLL_NUM_OF_EXTRA_CLKS) > 0} {

      set pll_master_user_clock_base [string range $pins(master_vco_clock) 0 [string last "|" $pins(master_vco_clock)] ]pll_inst|outclk

      set var(pll_num_of_reserved_cnts) 5

      for {set i 0} {$i < $var(PLL_NUM_OF_EXTRA_CLKS)} {incr i} {
         set i_cnt_num [expr $i + $var(pll_num_of_reserved_cnts)]
         set var(pll_c${i_cnt_num}_cnt) [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_calculate_counter_value $var(PLL_C_CNT_HIGH_${i_cnt_num}) $var(PLL_C_CNT_LOW_${i_cnt_num}) $var(PLL_C_CNT_BYPASS_EN_${i_cnt_num})]
         set pins(pll_extra_clk_${i}) "$pll_master_user_clock_base\[$i_cnt_num\]"
      }
   }
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_initialize_ddr_db { ddr_db_par var_array_name} {
   upvar $ddr_db_par local_ddr_db
   upvar 1 $var_array_name var

   global ::GLOBAL_ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_corename
   global ::io_only_analysis

   post_sdc_message info "Initializing DDR database for CORE $::GLOBAL_ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_corename"
   set instance_list [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_core_instance_list $::GLOBAL_ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_corename]

   foreach instname $instance_list {

      if {$::io_only_analysis == 0}  {
         post_sdc_message info "Finding port-to-pin mapping for CORE: $::GLOBAL_ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_corename INSTANCE: $instname"
         ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_ddr_pins $instname allpins var
         ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_verify_ddr_pins allpins var
      }

      set local_ddr_db($instname) [ array get allpins ]
   }
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_verify_ddr_pins { pins_par var_array_name} {

   upvar 1 $var_array_name var
   upvar $pins_par pins

   if { [ llength $pins(pll_phy_clock) ] != [ llength $pins(pll_vco_clock) ] } {
      post_message -type critical_warning "Found different amounts of the phy_clocks compared to the vco_clocks"
   }
   if {!$var(IS_HPS)} {
      if {$var(PHY_CONFIG_ENUM) == "CONFIG_PHY_AND_HARD_CTRL"} {
         if { [ llength $pins(master_core_usr_clock) ] != 1 } {
            post_message -type critical_warning "Found [ llength $pins(master_core_usr_clock) ] of master_core_usr_clock when there should be 1"
         }

         if {$var(USER_CLK_RATIO) == 2 && $var(C2P_P2C_CLK_RATIO) == 4} {
            if { [ llength $pins(master_core_usr_half_clock) ] != 1 } {
               post_message -type critical_warning "Found [ llength $pins(master_core_usr_half_clock) ] of master_core_usr_half_clock when there should be 1"
            }
         }

         if {$var(PHY_PING_PONG_EN)} {
            if { [ llength $pins(master_core_usr_clock_sec) ] != 1 } {
               post_message -type critical_warning "Found [ llength $pins(master_core_usr_clock_sec) ] of master_core_usr_clock_sec when there should be 1"
            }

            if {$var(USER_CLK_RATIO) == 2 && $var(C2P_P2C_CLK_RATIO) == 4} {
               if { [ llength $pins(master_core_usr_half_clock_sec) ] != 1 } {
                  post_message -type critical_warning "Found [ llength $pins(master_core_usr_half_clock_sec) ] of master_core_usr_half_clock_sec when there should be 1"
               }
            }
         }
      } else {
         if { [ llength $pins(master_core_afi_clock) ] != 1 } {
            post_message -type critical_warning "Found [ llength $pins(master_core_afi_clock) ] of master_core_afi_clock when there should be 1"
         }
      }
   }
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_all_instances_dqs_pins { ddr_db_par } {
   upvar $ddr_db_par local_ddr_db

   set dqs_pins [ list ]
   set instnames [ array names local_ddr_db ]
   foreach instance $instnames {
      array set pins $local_ddr_db($instance)

      foreach { dqs_pin } $pins(dqs_pins) {
         lappend dqs_pins ${dqs_pin}_IN
         lappend dqs_pins ${dqs_pin}_OUT
      }
      foreach { dqsn_pin } $pins(dqsn_pins) {
         lappend dqs_pins ${dqsn_pin}_OUT
      }
      foreach { ck_pin } $pins(ck_pins) {
         lappend dqs_pins $ck_pin
      }
   }

   return $dqs_pins
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_calculate_counter_value { cnt_hi cnt_lo cnt_bypass } {
   if {$cnt_bypass} {
      set result 1
   } else {
      set result [expr {$cnt_hi + $cnt_lo}]
   }
   return $result
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_input_clk_id { pll_inclk_id var_array_name} {
   upvar 1 $var_array_name var

   array set results_array [list]

   ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_traverse_fanin_up_to_depth $pll_inclk_id ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_is_node_type_pin clock results_array $var(pll_inclock_search_depth)
   if {[array size results_array] == 1} {
      set pin_id [lindex [array names results_array] 0]
      set result $pin_id
   } else {
      post_message -type critical_warning "Could not find PLL clock for [get_node_info -name $pll_inclk_id]"
      set result -1
   }

   return $result
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_output_clock_id { pin_list pin_type msg_list_name var_array_name} {
   upvar 1 $msg_list_name msg_list
   upvar 1 $var_array_name var
   set output_clock_id -1

   set output_id_list [list]
   set pin_collection [get_keepers -no_duplicates $pin_list]
   if {[get_collection_size $pin_collection] == [llength $pin_list]} {
      foreach_in_collection id $pin_collection {
         lappend output_id_list $id
      }
   } elseif {[get_collection_size $pin_collection] == 0} {
      lappend msg_list "warning" "Could not find any $pin_type pins"
   } else {
      lappend msg_list "warning" "Could not find all $pin_type pins"
   }
   ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_pll_clock $output_id_list $pin_type output_clock_id $var(pll_outclock_search_depth)
   return $output_clock_id
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_pll_clock { dest_id_list node_type clock_id_name search_depth} {
   if {$clock_id_name != ""} {
      upvar 1 $clock_id_name clock_id
   }
   set clock_id -1

   array set clk_array [list]
   foreach node_id $dest_id_list {
      ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_traverse_fanin_up_to_depth $node_id ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_is_node_type_pll_clk clock clk_array $search_depth
   }
   if {[array size clk_array] == 1} {
      set clock_id [lindex [array names clk_array] 0]
      set clk [get_node_info -name $clock_id]
   } elseif {[array size clk_array] > 1} {
      puts "Found more than 1 clock driving the $node_type"
      set clk ""
   } else {
      set clk ""
   }

   return $clk
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_vco_clk_id { wf_clock_id var_array_name} {
   upvar 1 $var_array_name var

   array set results_array [list]

   ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_traverse_fanin_up_to_depth $wf_clock_id ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_is_node_type_vco clock results_array $var(pll_vcoclock_search_depth)
   if {[array size results_array] == 1} {
      set pin_id [lindex [array names results_array] 0]
      set result $pin_id
   } else {
      post_message -type critical_warning "Could not find VCO clock for [get_node_info -name $wf_clock_id]"
      set result -1
   }

   return $result
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_is_node_type_pll_clk { node_id } {
   set cell_id [get_node_info -cell $node_id]

   if {$cell_id == ""} {
      set result 0
   } else {
      set atom_type [get_cell_info -atom_type $cell_id]
      if {$atom_type == "IOPLL"} {
         set node_name [get_node_info -name $node_id]

         if  {[regexp {pll_inst~.*OUTCLK[0-9]$} $node_name]} {
            set result 1
         } else {
            set result 0
         }
      } elseif {$atom_type == "TILE_CTRL"} {
         set node_name [get_node_info -name $node_id]

         if {[regexp {tile_ctrl_inst.*\|pa_core_clk_out\[[0-9]\]$} $node_name]} {
            set result 1
         } else {
            set result 0
         }
      } else {
         set result 0
      }
   }
   return $result
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_is_node_type_vco { node_id } {
   set cell_id [get_node_info -cell $node_id]

   if {$cell_id == ""} {
      set result 0
   } else {
      set atom_type [get_cell_info -atom_type $cell_id]
      if {$atom_type == "IOPLL"} {
         set node_name [get_node_info -name $node_id]

         if {[regexp {pll_inst.*\|.*vcoph\[0\]$} $node_name]} {
            set result 1
         } elseif {[regexp {pll_inst.*VCOPH0$} $node_name]} {
            set result 1
         } else {
            set result 0
         }
      } else {
         set result 0
      }
   }
   return $result
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_does_ref_clk_exist { ref_clk_name } {

   set ref_clock_found 0
   foreach_in_collection iclk [get_clocks -nowarn] {
      if { ![is_clock_defined $iclk] } {
         continue
      }
      set clk_targets [get_clock_info -target $iclk]
      foreach_in_collection itgt $clk_targets {
         set node_name [get_node_info -name $itgt]
         if {[string compare $node_name $ref_clk_name] == 0} {
            set ref_clock_found 1
            break
         }
      }
      if {$ref_clock_found == 1} {
         break;
      }
   }

   return $ref_clock_found
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_p2c_c2p_clock_uncertainty { instname var_array_name } {

   set success 1
   set error_message ""
   set clock_uncertainty 0
   set debug 0

   package require ::quartus::atoms
   upvar 1 $var_array_name var

   catch {read_atom_netlist} read_atom_netlist_out
   set read_atom_netlist_error [regexp "ERROR" $read_atom_netlist_out]

   if {$read_atom_netlist_error == 0} {
      if {[ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_are_entity_names_on]} {
         regsub -all {\|} $instname "|*:" instname
      }
      regsub -all {\\} $instname {\\\\} instname
      regsub -all {\[} $instname "\\\[" instname
      regsub -all {\]} $instname "\\\]" instname

      # Find the IOPLLs
      if {$success == 1} {
         if {[ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_are_entity_names_on]} {
            set pll_atoms [get_atom_nodes -matching *${instname}|*:arch|*:arch_inst|*:pll_inst|* -type IOPLL]
         } else {
            set pll_atoms [get_atom_nodes -matching *${instname}|arch|arch_inst|pll_inst|* -type IOPLL]
         }
         set num_pll_inst [get_collection_size $pll_atoms]

         if {$num_pll_inst == 0} {
            set success 0
            post_message -type critical_warning "The auto-constraining script was not able to detect any PLLs in the < $instname > memory interface."
         }
      }

      # Get atom parameters
      if {$success == 1} {

         set mcnt_list [list]
         set bw_list   [list]
         set cp_setting_list [list]
         set vco_period_list [list]

         foreach_in_collection pll_atom $pll_atoms {

            # M-counter value
            if {[get_atom_node_info -node $pll_atom -key  BOOL_IOPLL_M_COUNTER_BYPASS_EN] == 1} {
               set mcnt 1
            } else {
               set mcnt [expr [get_atom_node_info -node $pll_atom -key INT_IOPLL_M_COUNTER_HIGH] + [get_atom_node_info -node $pll_atom -key INT_IOPLL_M_COUNTER_LOW]]
            }
            lappend mcnt_list $mcnt

            # BW
            set bw [get_atom_node_info -node $pll_atom -key  ENUM_IOPLL_BW_MODE]
            if {[string compare -nocase $bw "AUTO"] == 0} {
               set bw "LBW"
            } elseif  {[string compare -nocase $bw "LOW_BW"] == 0} {
                set bw "LBW"
            } elseif  {[string compare -nocase $bw "MID_BW"] == 0} {
                set bw "MBW"
            } elseif  {[string compare -nocase $bw "HI_BW"] == 0} {
                set bw "HBW"
            }
            lappend bw_list $bw

            # CP current setting (stubbed out for now as this is set internally)
            set cp_setting PLL_CP_SETTING0
            lappend cp_setting_list $cp_setting

            # VCO frequency setting
            set vco_period [get_atom_node_info -node $pll_atom -key TIME_IOPLL_VCO]
            lappend vco_period_list $vco_period
         }

         # Make sure all IOPLL parameters are the same
         for {set i [expr [llength $mcnt_list] - 1]} {$i > 0} {set i [expr $i - 1]} {
            if {[lindex $mcnt_list $i] != [lindex $mcnt_list [expr $i - 1]]} {
               set success 0
               post_message -type critical_warning "The auto-constraining script found multiple PLLs in the < $instname > memory interface with different parameters."
            }
         }
         for {set i [expr [llength $bw_list] - 1]} {$i > 0} {set i [expr $i - 1]} {
            set bw_a [lindex $bw_list $i]
            set bw_b [lindex $bw_list [expr $i - 1]]
            if {[string compare -nocase $bw_a $bw_b] != 0} {
               set success 0
               post_message -type critical_warning "The auto-constraining script found multiple PLLs in the < $instname > memory interface with different parameters."
            }
         }
         for {set i [expr [llength $cp_setting_list] - 1]} {$i > 0} {set i [expr $i - 1]} {
            set cp_a [lindex $cp_setting_list $i]
            set cp_b [lindex $cp_setting_list [expr $i - 1]]
            if {[string compare -nocase $cp_a $cp_b] != 0} {
               set success 0
               post_message -type critical_warning "The auto-constraining script found multiple PLLs in the < $instname > memory interface with different parameters."
            }
         }

         for {set i [expr [llength $vco_period_list] - 1]} {$i > 0} {set i [expr $i - 1]} {
            set vco_a [lindex $vco_period_list $i]
            set vco_b [lindex $vco_period_list [expr $i - 1]]
            if {[string compare -nocase $vco_a $vco_b] != 0} {
               set success 0
               post_message -type critical_warning "The auto-constraining script found multiple PLLs in the < $instname > memory interface with different parameters."
            }
         }
      }

      # Calculate clock uncertainty
      if {$success == 1} {

         set mcnt [lindex $mcnt_list 0]
         set bw   [string toupper [lindex $bw_list 0]]
         set cp_setting [lindex $cp_setting_list 0]
         set cp_current [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_cp_current_from_setting $cp_setting]
         set vco_period [lindex $vco_period_list 0]
         if {[regexp {([0-9]+) ps} $vco_period matched vco_period] == 1} {
         } else {
            post_message -type critical_warning "The auto-constraining script was not able to read the netlist."
            set success 0
         }
         set vco_frequency_in_mhz [expr 1000000 / $vco_period]

         if {$debug} {
            puts "MCNT : $mcnt"
            puts "BW   : $bw"
            puts "CP   : $cp_setting ($cp_current)"
            puts "VCO  : $vco_period"
         }

         set HFR  [get_clock_frequency_uncertainty_data PLL $vco_frequency_in_mhz $bw OFFSET${mcnt} HFR]
         set LFD  [get_clock_frequency_uncertainty_data PLL $vco_frequency_in_mhz $bw OFFSET${mcnt} LFD]
         set SPE  [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_spe_from_cp_current $cp_current]

         if {$success == 1} {
            set clock_uncertainty_sqrt  [expr sqrt(($LFD/2)*($LFD/2) + ($LFD/2)*($LFD/2))]
            set clock_uncertainty [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_round_3dp [expr ($clock_uncertainty_sqrt + $SPE)*1e9]]

            if {$debug} {
               puts "HFR  : $HFR"
               puts "LFD  : $LFD"
               puts "SPE  : $SPE"
               puts "TOTAL: $clock_uncertainty"
            }
         }
      }

   } else {
      set success 0
      post_message -type critical_warning "The auto-constraining script was not able to read the netlist."
   }

   # Output warning in the case that clock uncertainty can't be determined
   if {$success == 0} {
      post_message -type critical_warning "Verify the following:"
      post_message -type critical_warning " The core < $instname > is instantiated within another component (wrapper)"
      post_message -type critical_warning " The core is not the top-level of the project"
      post_message -type critical_warning " The memory interface pins are exported to the top-level of the project"
      post_message -type critical_warning " The core  < $instname > RTL has not been modified manually"
   }

   return $clock_uncertainty
}


proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_cp_current_from_setting { cp_setting } {

   set cp_current 0

   if {[string compare -nocase $cp_setting "PLL_CP_SETTING0"] == 0} {
      set cp_current 0
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING1"] == 0} {
      set cp_current 5	
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING2"] == 0} {
      set cp_current 10
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING3"] == 0} {
      set cp_current 15
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING4"] == 0} {
      set cp_current 20	
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING5"] == 0} {
      set cp_current 25		
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING6"] == 0} {
      set cp_current 30
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING7"] == 0} {
      set cp_current 35	
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING8"] == 0} {
      set cp_current 40	
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING9"] == 0} {
      set cp_current 45
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING10"] == 0} {
      set cp_current 50	
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING11"] == 0} {
      set cp_current 55			
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING12"] == 0} {
      set cp_current 60
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING13"] == 0} {
      set cp_current 65			
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING14"] == 0} {
      set cp_current 70	
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING15"] == 0} {
      set cp_current 75			
	} else {
      set cp_current 0
   }

   return $cp_current
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_spe_from_cp_current { cp_current } {

   set spe 158.0e-12

   if {$cp_current <= 15} {
      set spe 158e-012 
   } elseif {$cp_current <= 20} {
      set spe 130.62e-12 
   } elseif {$cp_current <= 25} {
      set spe 117.3e-12 
   } elseif {$cp_current <= 30} {
      set spe 109.5e-12 
   } elseif {$cp_current <= 35} {
      set spe 104.5e-12 
   } elseif {$cp_current <= 40} {
      set spe 100.9e-12 
   } elseif {$cp_current <= 60} {
      set spe 93.3e-12 
   } else {
      set spe 93.3e-12 
   }
   
   return $spe
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_periphery_clock_uncertainty { results_array_name var_array_name } {
   upvar 1 $results_array_name results
   upvar 1 $var_array_name var

   if {$var(DIAG_TIMING_REGTEST_MODE)} {
      set c2p_setup  0.050
      set c2p_hold   0.0
      set p2c_setup  0.050
      set p2c_hold   0.0
   } else {
      set c2p_setup  0.0
      set c2p_hold   0.0
      set p2c_setup  0.0
      set p2c_hold   0.0
   }

   set results [list $c2p_setup $c2p_hold $p2c_setup $p2c_hold]
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_core_clock_uncertainty { results_array_name var_array_name } {
   upvar 1 $results_array_name results
   upvar 1 $var_array_name var

   set c2c_same_setup  0
   set c2c_same_hold   0
   set c2c_diff_setup  0
   set c2c_diff_hold   0

   set results [list $c2c_same_setup $c2c_same_hold $c2c_diff_setup $c2c_diff_hold]
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_core_overconstraints { results_array_name var_array_name } {
   upvar 1 $results_array_name results
   upvar 1 $var_array_name var

   set results [list $var(C2C_SAME_CLK_SETUP_OC_NS) $var(C2C_SAME_CLK_HOLD_OC_NS) $var(C2C_DIFF_CLK_SETUP_OC_NS) $var(C2C_DIFF_CLK_HOLD_OC_NS)]
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_periphery_overconstraints { results_st_array_name results_mt_array_name var_array_name } {
   upvar 1 $results_st_array_name results_st
   upvar 1 $results_mt_array_name results_mt
   upvar 1 $var_array_name var

   set c2p_p2c_frequency [expr $var(PHY_MEM_CLK_FREQ_MHZ)/$var(C2P_P2C_CLK_RATIO)]

   set results_st [list $var(C2P_SETUP_OC_NS) $var(C2P_HOLD_OC_NS) $var(P2C_SETUP_OC_NS) $var(P2C_HOLD_OC_NS)]
   set results_mt [list [expr $var(C2P_SETUP_OC_NS) + 0.000] [expr $var(C2P_HOLD_OC_NS) + 0.000] [expr $var(P2C_SETUP_OC_NS) + 0.000] [expr $var(P2C_HOLD_OC_NS) + 0.000]]

}


proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_sort_duplicate_names { names_array } {

   set main_name ""
   set duplicate_names [list]

   # Find the main name as opposed to all the duplicate names
   foreach { name } $names_array {
      if  {[regexp {Duplicate} $name]} {
         lappend duplicate_names $name
      } else {
         if {$main_name == ""} {
            set main_name $name
         } else {
            post_message -type error "More than one main tile name ($main_name and $name).  Please verify the connectivity of these pins."
         }
      }
   }

   # Now sort the duplicate names
   set duplicate_names [lsort -decreasing $duplicate_names]

   # Prepend the main name and then return
   set result [join [linsert $duplicate_names 0 $main_name]]

   return $result
}

 13 0 1 / 4 home 7 mustafa 8 projects 15 cva6_intel_fpga 4 cva6 9 corev_apu 5 intel 2 ip 18 ed_synth_emif_fm_0 23 altera_emif_arch_fm_191 5 synth 71 ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_report_io_timing.tcl 8209 # (C) 2001-2024 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file contains the routines to generate the early external memory
# interface timing report at the before the start of the compile flow.
#
# These routines are only meant to be used in this specific context.
# Trying to using them in a different context can have unexpected
# results.
#
# In performing the above timing analysis, the script
# calls procedures that are found in a separate file (report_timing_core.tcl)
# that has all the details of the timing analysis, and this
# file only serves as the top-level timing analysis flow.
#
# To reduce data lookups in all the procuedures that perform
# the individual timing analysis, data that is needed for
# multiple procedures is lookup up in this file and passed
# to the various parameters.  These data include both values
# that are applicable over all operating conditions, and those
# that are applicable to only one operating condition.
#
#############################################################

# Determin if only doing IO analysis
set ::io_only_analysis 1

#############################################################
# Initialize the environment / Error Checking
#############################################################

if { ![info exists quartus(nameofexecutable)] || $quartus(nameofexecutable) != "quartus_sta" } {
   post_message -type error "This script must be run from quartus_sta"
   return 1
}

# Check the project
if { ! [ is_project_open ] } {
   if { [ llength $quartus(args) ] > 0 } {
      set project_name [lindex $quartus(args) 0]
      project_open -revision [ get_current_revision $project_name ] $project_name
   } else {
      post_message -type error "Missing project_name argument"
      return 1
   }
}


# Load the timing netlist if required
if { ! [timing_netlist_exist] } {
   # In IO only flow, check to see if we could even create a timing nelist
   # First try to see if we could even create a
   catch {create_timing_netlist} create_timing_netlist_out
   set create_timing_netlist_error [regexp "ERROR" $create_timing_netlist_out]

   # If create timing netlist cannot run, then the IO flow is a valid flow
   if {$create_timing_netlist_error == 1} {
      create_emif_netlist -revision $::quartus(project)
      sta_create_empty_report
   } else {
      delete_timing_netlist
      post_message -type error "Early EMIF IO timing estimate cannot be run once the Fitter has been run"
      return 1
   }

} else {
   post_message -type error "Early EMIF IO timing estimate cannot be run once the Fitter has been run"
   return 1
}

# Load the reports
load_package report
set current_timing_report_type [get_current_report_type]
if { [catch {load_report_database -type_name $current_timing_report_type} load_report_out ] } {
   create_report_database -type_name $current_timing_report_type
}

#############################################################
# Some useful functions
#############################################################
set script_dir [file dirname [info script]]
source "$script_dir/ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_ip_parameters.tcl"
source "$script_dir/ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_parameters.tcl"
source "$script_dir/ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_pin_map.tcl"
source "$script_dir/ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_report_timing_core.tcl"


if [ info exists ddr_db ] {
   unset ddr_db
}
ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_initialize_ddr_db ddr_db var


# If multiple instances of this core are present in the
# design they will all be analyzed through the
# following loop
set instances [ array names ddr_db ]
set inst_id 0
foreach inst $instances {

   if { [ info exists pins ] } {
      # Clean-up stale content
      unset pins
   }
   array set pins $ddr_db($inst)

   #################################################################################
   # Find some design values and parameters that will used during the timing analysis
   # that do not change accross the operating conditions

   set fname ""
   set fbasename ""
   if {[llength $instances] <= 1} {
      set fbasename "${::GLOBAL_ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_corename}"
   } else {
      set fbasename "${::GLOBAL_ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_corename}_${inst_id}"
   }

   #################################################################################
   # Now loop the timing analysis over the various operating conditions
   set summary [list]

   set opcname "All conditions"
   set opcname [string trim $opcname]

   #######################################
   # PHY Analyses

   ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_perform_core_analysis $opcname $inst pins var summary

   #######################################
   # Print out the Summary Panel for this instance

   set summary [lsort -command ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_sort_proc $summary]

   post_message -type info "Core: ${::GLOBAL_ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_corename} - Instance: $inst"
   post_message -type info "                                                         setup  hold"
   set panel_name "[get_report_folder -relative]||$inst"
   # Delete any pre-existing summary panel
   set panel_id [get_report_panel_id $panel_name]
   if {$panel_id != -1} {
      delete_report_panel -id $panel_id
   }

   # Create summary panel
   set total_failures 0
   set rows [list]
   lappend rows "add_row_to_table -id \$panel_id \[list \"Path\" \"Operating Condition\" \"Setup Slack\" \"Hold Slack\"\]"
   foreach summary_line $summary {
      foreach {corner order path su hold num_su num_hold} $summary_line { }
      if {($num_su == 0) || ([string trim $su] == "")} {
         set su "--"
      }
      if {($num_hold == 0) || ([string trim $hold] == "")} {
         set hold "--"
      }


      if { ($su != "--" && $su < 0) || ($hold != "--" && $hold < 0) } {
         incr total_failures
         set type warning
         set offset 50
      } else {
         set type info
         set offset 53
      }
      if {$su != "--"} {
         set su [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_round_3dp $su]
      }
      if {$hold != "--"} {
         set hold [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_round_3dp $hold]
      }
      post_message -type $type [format "%-${offset}s | %6s %6s" $path $su $hold]
      set fg_colours [list black black]
      if { $su != "--" && $su < 0 } {
         lappend fg_colours red
      } else {
         lappend fg_colours black
      }

      if { $hold != "" && $hold < 0 } {
         lappend fg_colours red
      } else {
         lappend fg_colours black
      }
      lappend rows "add_row_to_table -id \$panel_id -fcolors \"$fg_colours\" \[list \"$path\" \"$corner\" \"$su\" \"$hold\"\]"
   }
   if {$total_failures > 0} {
      post_message -type critical_warning "DDR Timing requirements not met"
      set panel_id [create_report_panel -table $panel_name -color red]
   } else {
      set panel_id [create_report_panel -table $panel_name]
   }
   foreach row $rows {
      eval $row
   }

   incr inst_id
}
# end foreach inst


 13 0 1 / 4 home 7 mustafa 8 projects 15 cva6_intel_fpga 4 cva6 9 corev_apu 5 intel 2 ip 18 ed_synth_emif_fm_0 23 altera_emif_arch_fm_191 5 synth 68 ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_report_timing.tcl 10202 # (C) 2001-2024 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file contains the routines to generate the external memory
# interface timing report at the end of the compile flow.
#
# These routines are only meant to be used in this specific context.
# Trying to using them in a different context can have unexpected
# results.
#
# In performing the above timing analysis, the script
# calls procedures that are found in a separate file (report_timing_core.tcl)
# that has all the details of the timing analysis, and this
# file only serves as the top-level timing analysis flow.
#
# To reduce data lookups in all the procuedures that perform
# the individual timing analysis, data that is needed for
# multiple procedures is lookup up in this file and passed
# to the various parameters.  These data include both values
# that are applicable over all operating conditions, and those
# that are applicable to only one operating condition.
#
#############################################################

# Determine if only doing IO analysis
set ::io_only_analysis 0

#############################################################
# Initialize the environment / Error Checking
#############################################################

proc get_speedgrade_from_opn {part} {
   set temp_grade [get_part_info -temperature_grade $part]
   set speed_grade [get_part_info -speed_grade $part]
   set power_model [get_part_info -power_model $part]

   if {$temp_grade == "Extended"} {
      set temp_grade "E"
   } elseif {$temp_grade == "Industrial"} {
      set temp_grade "I"
   } elseif {$temp_grade == "Commercial"} {
      set temp_grade "C"
   } else {
      set temp_grade [string index $part 12]
   }

   if {$power_model == "{Standard Power}"} { 
      set power_model "V"
   } elseif {$power_model == "{Lower Power}"} {
      set power_model "E"
   } elseif {$power_model == "{Extreme Low Power}"} {
      set power_model "X"
   } elseif {$power_model == "{Fixed Voltage}"} {
      set power_model "F"
   } else {
      set power_model [string index $part 14]
   }

   set retval $temp_grade
   append retval $speed_grade
   append retval $power_model
   return $retval
}

if { ![info exists quartus(nameofexecutable)] || $quartus(nameofexecutable) != "quartus_sta" } {
   post_message -type error "This script must be run from quartus_sta"
   return 1
}

# Check the project
if { ! [ is_project_open ] } {
   if { [ llength $quartus(args) ] > 0 } {
		set project_name [lindex $quartus(args) 0]
		project_open -revision [ get_current_revision $project_name ] $project_name
	} else {
		post_message -type error "Missing project_name argument"
		return 1
	}
}


# Load the timing netlist if required
if { ! [timing_netlist_exist] } {
   create_timing_netlist
   read_sdc
   update_timing_netlist

   set script_dir [file dirname [info script]]
   source "$script_dir/ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_ip_parameters.tcl"
   source "$script_dir/ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_parameters.tcl"
   source "$script_dir/ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_pin_map.tcl"
   source "$script_dir/ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_report_timing_core.tcl"
   if { ! [timing_netlist_exist] } {
      post_message -type error "Timing Netlist has not been created. Run the 'Update Timing Netlist' task first."
      return 1
   }
}


# Load the atom netlist if required
load_package atoms
read_atom_netlist

# Load the reports
load_package report
set current_timing_report_type [get_current_report_type]
load_report_database -type_name $current_timing_report_type

#############################################################
# Some useful functions
#############################################################
set script_dir [file dirname [info script]]
source "$script_dir/ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_ip_parameters.tcl"
source "$script_dir/ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_parameters.tcl"
source "$script_dir/ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_pin_map.tcl"
source "$script_dir/ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_report_timing_core.tcl"

###############################################
# This is the main call to the netlist traversal routines
# that will automatically find all pins and registers required
# to timing analyze the Core.

if [ info exists ddr_db ] {
   unset ddr_db
}
ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_initialize_ddr_db ddr_db var

set old_active_clocks [get_active_clocks]
set_active_clocks [all_clocks]

# If multiple instances of this core are present in the
# design they will all be analyzed through the
# following loop
set instances [ array names ddr_db ]
set inst_id 0
foreach inst $instances {

   if { [ info exists pins ] } {
      # Clean-up stale content
      unset pins
   }
   array set pins $ddr_db($inst)

   #################################################################################
   # Find some design values and parameters that will used during the timing analysis
   # that do not change accross the operating conditions

   set fname ""
   set fbasename ""
   if {[llength $instances] <= 1} {
      set fbasename "${::GLOBAL_ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_corename}"
   } else {
      set fbasename "${::GLOBAL_ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_corename}_${inst_id}"
   }

   #################################################################################
   # Now loop the timing analysis over the various operating conditions
   set summary [list]

   set opcname [get_operating_conditions_info [get_operating_conditions] -display_name]
   set hold_only_corner [get_operating_conditions_info [get_operating_conditions] -is_hold_only]
   set opcname [string trim $opcname]

   if {$hold_only_corner} {
      set opcname "${opcname}, Hold Only"
   }

   ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_perform_core_analysis $opcname $inst pins var summary


   set summary [lsort -command ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_sort_proc $summary]

   post_message -type info "Core: ${::GLOBAL_ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_corename} - Instance: $inst"
   post_message -type info "                                                               setup  hold"
   set panel_name "[get_report_folder -relative]||$inst"
   # Delete any pre-existing summary panel
   set panel_id [get_report_panel_id $panel_name]
   if {$panel_id != -1} {
      delete_report_panel -id $panel_id
   }

   # Create summary panel
   set total_failures 0
   set rows [list]
   lappend rows "add_row_to_table -id \$panel_id \[list \"Path\" \"Operating Condition\" \"Setup Slack\" \"Hold Slack\"\]"
   foreach summary_line $summary {
      foreach {corner order path su hold num_su num_hold} $summary_line { }
      if {($num_su == 0) || ([string trim $su] == "")} {
         set su "--"
      }
      if {($num_hold == 0) || ([string trim $hold] == "")} {
         set hold "--"
      }

      set type info
      set offset 59

      if { ($su != "--" && $su < 0) || ($hold != "--" && $hold < 0) } {
         incr total_failures
      }
      if {$su != "--"} {
         set su [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_round_3dp $su]
      }
      if {$hold != "--"} {
         set hold [ ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_round_3dp $hold]
      }
      post_message -type $type [format "%-${offset}s | %6s %6s" $path $su $hold]
      set fg_colours [list black black]
      if { $su != "--" && $su < 0 } {
         lappend fg_colours red
      } else {
         lappend fg_colours black
      }

      if { $hold != "" && $hold < 0 } {
         lappend fg_colours red
      } else {
         lappend fg_colours black
      }
      lappend rows "add_row_to_table -id \$panel_id -fcolors \"$fg_colours\" \[list \"$path\" \"$corner\" \"$su\" \"$hold\"\]"
   }
   if {$total_failures > 0} {
      post_message -type critical_warning "DDR Timing requirements not met"
      set panel_id [create_report_panel -table $panel_name -color red]
   } else {
      set panel_id [create_report_panel -table $panel_name]
   }
   foreach row $rows {
      eval $row
   }

   incr inst_id
}
# end foreach inst


set_active_clocks $old_active_clocks

set curr_part $::TimeQuestInfo(part)
set curr_speedgrade [get_speedgrade_from_opn $curr_part]

if {![test_part_trait_of $curr_part -trait FINAL_TIMING_MODEL]} {
   post_message -type critical_warning "Timing analysis was performed using a non-final timing model and/or constraints. You must regenerate the external memory interface IP and recheck timing closure in a future version of Quartus Prime."
}

if {$var(PHY_TARGET_SPEEDGRADE) == ""} {
   set effective_target_speedgrade "E1"
} else {
   set effective_target_speedgrade $var(PHY_TARGET_SPEEDGRADE)
}

if {$curr_speedgrade != $effective_target_speedgrade} {
   post_message -type critical_warning "This External Memory Interface IP core was generated for a speed grade $effective_target_speedgrade device, but the speed grade of $curr_part is $curr_speedgrade. You should regenerate the IP core to match the target device to avoid hardware issue."
}
 13 0 1 / 4 home 7 mustafa 8 projects 15 cva6_intel_fpga 4 cva6 9 corev_apu 5 intel 2 ip 18 ed_synth_emif_fm_0 23 altera_emif_arch_fm_191 5 synth 73 ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_report_timing_core.tcl 12643 # (C) 2001-2024 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.




################################################################
# Helper function to add a report_timing-based analysis section
################################################################
proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_add_report_timing_analysis {opcname inst var_array_name summary_name title from_clks to_clks from_nodes to_nodes } {

   #######################################
   # Need access to global variables
   upvar 1 $summary_name global_summary
   upvar 1 $var_array_name var

   set num_failing_path 10

   set setup_margin    999.9
   set hold_margin     999.9
   set recovery_margin 999.9
   set removal_margin  999.9

   set hold_only_corner [get_operating_conditions_info [get_operating_conditions] -is_hold_only]

   if {!$hold_only_corner && ([get_collection_size [get_timing_paths -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths 1 -setup]] > 0)} {
      set res_0        [report_timing -quiet -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name "$inst $title (setup)" -setup]
      set setup_margin [lindex $res_0 1]
   } else {
      set setup_margin "--"
   }

   if {[get_collection_size [get_timing_paths -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths 1 -hold]] > 0} {
      set res_1        [report_timing -quiet -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name "$inst $title (hold)" -hold]
      set hold_margin  [lindex $res_1 1]
   }

   if {$var(DIAG_TIMING_REGTEST_MODE)} {
      lappend global_summary [list $opcname 0 "$title ($opcname)" $setup_margin $hold_margin]
   }

   if {!$hold_only_corner && ([get_collection_size [get_timing_paths -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths 1 -recovery]] > 0)} {
      set res_0           [report_timing -quiet -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name "$inst $title (recovery)" -recovery]
      set recovery_margin [lindex $res_0 1]
   } else {
      set recovery_margin "--"
   }

   if {[get_collection_size [get_timing_paths -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths 1 -removal]] > 0} {
      set res_1           [report_timing -quiet -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name "$inst $title (removal)" -removal]
      set removal_margin  [lindex $res_1 1]
   } else {
      set removal_margin "--"
   }

   if {$var(DIAG_TIMING_REGTEST_MODE)} {
      lappend global_summary [list $opcname 0 "$title Recovery/Removal ($opcname)" $recovery_margin $removal_margin]
   }

   return [list $setup_margin $hold_margin $recovery_margin $removal_margin]
}

#############################################################
# Other Core-Logic related Timing Analysis
#############################################################

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_add_c2p_p2c_report_timing_analysis {opcname inst pin_array_name var_array_name summary_name title from_clks to_clks from_nodes to_nodes p2c} {

   #######################################
   # Need access to global variables
   upvar 1 $summary_name global_summary
   upvar 1 $var_array_name var
   upvar 1 $pin_array_name pins

   set num_failing_path 10

   set setup_margin    999.9
   set hold_margin     999.9
   set recovery_margin 999.9
   set removal_margin  999.9
   set debug 0

   set hold_only_corner [get_operating_conditions_info [get_operating_conditions] -is_hold_only]

   set positive_fcolour [list "black" "blue" "blue"]
   set negative_fcolour [list "black" "red"  "red"]
   set summary [list]

   # Get the periphery clocks
   if {$p2c} {
      set phyclks $from_clks
   } else {
      set phyclks $to_clks
   }

   # Set panel names
   set panel_name_setup  "$inst $title (setup)"
   set panel_name_hold   "$inst $title (hold)"
   set panel_name_recovery  "$inst $title (recovery)"
   set panel_name_removal   "$inst $title (removal)"	
   set disable_panel_color_flag ""
   set quiet_flag ""

   # Generate the default margins
   if {!$hold_only_corner} {
      set res_0        [report_timing -quiet -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name $panel_name_setup -setup $disable_panel_color_flag $quiet_flag]
      set setup_margin [lindex $res_0 1]
   } else {
      set setup_margin "--"
   }
   set res_1        [report_timing -quiet -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name $panel_name_hold -hold $disable_panel_color_flag $quiet_flag]
   set hold_margin  [lindex $res_1 1]

   set recovery_paths 0
   set removal_paths 0

   if {!$hold_only_corner && ([get_collection_size [get_timing_paths -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths 1 -recovery]] > 0)} {
      set recovery_paths 1
      set res_2        [report_timing -quiet -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name $panel_name_recovery -recovery $disable_panel_color_flag $quiet_flag]
      set recovery_margin [lindex $res_2 1]
   } else {
      set recovery_margin "--"
   }

   if {[get_collection_size [get_timing_paths -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths 1 -removal]] > 0} {
      set removal_paths 1
      set res_3        [report_timing -quiet -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name $panel_name_removal  -removal  $disable_panel_color_flag $quiet_flag]
	   set removal_margin  [lindex $res_3 1]
   } else {
	   set removal_margin  "--"
   }

   if {$var(DIAG_TIMING_REGTEST_MODE)} {
      lappend global_summary [list $opcname 0 "$title ($opcname)" $setup_margin $hold_margin]
      if {($recovery_paths == 1) || ($removal_paths == 1)} {
         lappend global_summary [list $opcname 0 "$title Recovery/Removal ($opcname)" $recovery_margin $hold_margin]
      }
   }

   return [list $setup_margin $hold_margin $recovery_margin $removal_margin]
}


proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_perform_core_analysis {opcname inst pin_array_name var_array_name summary_name} {

   #######################################
   # Need access to global variables
   upvar 1 $summary_name global_summary
   upvar 1 $var_array_name var
   upvar 1 $pin_array_name pins
   global ::io_only_analysis

   # Debug switch. Change to 1 to get more run-time debug information
   set debug 0
   set result 1

   ###############################
   # PHY analysis
   ###############################

   set analysis_name "Core"

   if {$::io_only_analysis == 1} {
      set setup_slack "--"
      set hold_slack  "--"
      lappend global_summary [list $opcname 0 "$analysis_name ($opcname)" $setup_slack $hold_slack]
      post_message -type warning "Early EMIF IO timing estimate does not include core FPGA timing"
   } elseif {$var(IS_HPS)} {
      # No core timing analysis required by HPS interface
      set setup_slack "--"
      set hold_slack  "--"
      lappend global_summary [list $opcname 0 "$analysis_name ($opcname)" $setup_slack $hold_slack]
      lappend global_summary [list $opcname 0 "$analysis_name Recovery/Removal ($opcname)" $setup_slack $hold_slack]
   } else {

      set master_instname $pins(master_instname)
      set coreclkname [list ${master_instname}_core_usr_* ${master_instname}_core_afi_* ${master_instname}_core_dft_* ${master_instname}_ref_clock ${master_instname}_core_nios_clk [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_clock_name_from_pin_name $pins(pll_ref_clock)]]
      set coreclks [get_clocks -nowarn $coreclkname]

      set phyclkname [list ${inst}_phy_*]
      set phyclks [get_clocks -nowarn $phyclkname]

      set emif_regs [get_registers $inst|*]
      set rest_regs [remove_from_collection [all_registers] $emif_regs]

      set setup_margin    999.9
      set hold_margin     999.9
      set recovery_margin 999.9
      set removal_margin  999.9

      # Core/periphery transfers

      # Core-to-periphery
      set res [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_add_c2p_p2c_report_timing_analysis $opcname $inst $pin_array_name var global_summary "Core To Periphery" $coreclks $phyclks "*" $emif_regs 0]
      set setup_margin    [min $setup_margin    [lindex $res 0]]
      set hold_margin     [min $hold_margin     [lindex $res 1]]
      set recovery_margin [min $recovery_margin [lindex $res 2]]
      set removal_margin  [min $removal_margin  [lindex $res 3]]

      # Periphery-to-core
      set res [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_add_c2p_p2c_report_timing_analysis $opcname $inst $pin_array_name var global_summary "Periphery To Core" $phyclks $coreclks $emif_regs "*" 1]
      set setup_margin    [min $setup_margin    [lindex $res 0]]
      set hold_margin     [min $hold_margin     [lindex $res 1]]
      set recovery_margin [min $recovery_margin [lindex $res 2]]
      set removal_margin  [min $removal_margin  [lindex $res 3]]

      # Pure Core transfers

      set_active_clocks [remove_from_collection [all_clocks] $phyclks]

      # EMIF logic within FPGA core
      set res [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_add_report_timing_analysis $opcname $inst var global_summary "Within Core" $coreclks $coreclks $emif_regs $emif_regs]
      set setup_margin    [min $setup_margin    [lindex $res 0]]
      set hold_margin     [min $hold_margin     [lindex $res 1]]
      set recovery_margin [min $recovery_margin [lindex $res 2]]
      set removal_margin  [min $removal_margin  [lindex $res 3]]

      # Transfers between EMIF and user logic
      set res [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_add_report_timing_analysis $opcname $inst var global_summary "IP to User Logic" "*" "*" $emif_regs $rest_regs]
      set setup_margin    [min $setup_margin    [lindex $res 0]]
      set hold_margin     [min $hold_margin     [lindex $res 1]]
      set recovery_margin [min $recovery_margin [lindex $res 2]]
      set removal_margin  [min $removal_margin  [lindex $res 3]]

      # Transfers between user and EMIF logic
      set res [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_add_report_timing_analysis $opcname $inst var global_summary "User Logic to IP" "*" "*" $rest_regs $emif_regs]
      set setup_margin    [min $setup_margin    [lindex $res 0]]
      set hold_margin     [min $hold_margin     [lindex $res 1]]
      set recovery_margin [min $recovery_margin [lindex $res 2]]
      set removal_margin  [min $removal_margin  [lindex $res 3]]

      # Transfers within non-EMIF logic (not reported by default since they are irrelevant to EMIF IP)
      if {$var(DIAG_TIMING_REGTEST_MODE)} {
         set res [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_add_report_timing_analysis $opcname $inst var global_summary "Within User Logic" $coreclks $coreclks $rest_regs $rest_regs]
         set setup_margin    [min $setup_margin    [lindex $res 0]]
         set hold_margin     [min $hold_margin     [lindex $res 1]]
         set recovery_margin [min $recovery_margin [lindex $res 2]]
         set removal_margin  [min $removal_margin  [lindex $res 3]]
      }

      set_active_clocks [all_clocks]

      lappend global_summary [list $opcname 0 "$analysis_name ($opcname)" $setup_margin $hold_margin]
      lappend global_summary [list $opcname 0 "$analysis_name Recovery/Removal ($opcname)" $recovery_margin $removal_margin]
   }
}


 13 0 1 / 4 home 7 mustafa 8 projects 15 cva6_intel_fpga 4 cva6 9 corev_apu 5 intel 2 ip 18 ed_synth_emif_fm_0 23 altera_emif_arch_fm_191 5 synth 60 ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_utils.tcl 19617 # (C) 2001-2024 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.



set script_dir [file dirname [info script]]

load_package sdc_ext
load_package design

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_index_in_collection { col j } {
   set i 0
   foreach_in_collection path $col {
      if {$i == $j} {
         return $path
      }
      set i [expr $i + 1]
   }
   return ""
}


proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_clock_to_pin_name_mapping {} {
   set result [list]
   set clocks_collection [get_clocks]
   foreach_in_collection clock $clocks_collection {
      if { ![is_clock_defined $clock] } {
         continue
      }
      set clock_name [get_clock_info -name $clock]
      set clock_target [get_clock_info -targets $clock]
      set first_index [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_index_in_collection $clock_target 0]
      set catch_exception_net [catch {get_net_info -name $first_index} pin_name_net]
      if {$catch_exception_net == 0} {
         lappend result [list $clock_name $pin_name_net]
      } else {
         set catch_exception_port [catch {get_port_info -name $first_index} pin_name_port]
         if {$catch_exception_port == 0} {
            lappend result [list $clock_name $pin_name_port]
         } else {
            set catch_exception_reg [catch {get_register_info -name $first_index} pin_name_reg]
            if {$catch_exception_reg == 0} {
               lappend result [list $clock_name $pin_name_reg]
            } else {
               set catch_exception_pin [catch {get_pin_info -name $first_index} pin_name_pin]
               if {$catch_exception_pin == 0} {
                  lappend result [list $clock_name $pin_name_pin]
               }
            }
         }
      }
   }
   return $result
}


proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_clock_name_from_pin_name { pin_name } {
   set table [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_clock_to_pin_name_mapping]
   foreach entry $table {
      if {[string compare [lindex [lindex [split $entry] 1] 0] $pin_name] == 0} {
         return [lindex $entry 0]
      }
   }
   return ""
}



proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_find_all_keepers { mystring } {
   set allkeepers [get_keepers $mystring ]

   foreach_in_collection keeper $allkeepers {
      set keepername [ get_node_info -name $keeper ]

      puts "$keepername"
   }
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_round_3dp { x } {
   return [expr { round($x * 1000) / 1000.0  } ]
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_current_timequest_report_folder {} {

   set catch_exception [catch {get_current_timequest_report_folder} error_message]
   if {[regexp ERROR $error_message] == 1} {
      return "ReportDDR"
   } else {
      return [get_current_timequest_report_folder]
   }
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_timequest_name {hier_name} {
   set sta_name $hier_name
   return $sta_name
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_are_entity_names_on { } {
   return [set_project_mode -is_show_entity]
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_core_instance_list {corename} {
   global ::io_only_analysis

   if {$::io_only_analysis == 1}  {
      set instance_list [list $corename]

   } else {
      set full_instance_list [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_core_full_instance_list $corename]
      set instance_list [list]

      foreach inst $full_instance_list {
         set sta_name [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_timequest_name $inst]
         if {[lsearch $instance_list [escape_brackets $sta_name]] == -1} {
            lappend instance_list $sta_name
         }
      }

   }
   return $instance_list
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_or_add_generated_clock {args} {
   array set opts [list -name "" -target "" -source "" -multiply_by 1 -divide_by 1 -phase 0]
   array set opts $args

   set multiply_by [expr int($opts(-multiply_by))]
   if {[expr $multiply_by - $opts(-multiply_by)] != 0.0} {
      post_message -type error "Specify an integer ranging from 0 to 99999999 for the option -multiply_by"
      return ""
   }

   set clock_name [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_clock_name_from_pin_name $opts(-target)]

   if {[string compare -nocase $clock_name ""] == 0} {
      set nets [get_nets $opts(-target) -nowarn]
      if {[get_collection_size $nets] > 0} {
         set pin_name [get_pin_info -name [get_net_info -pin $nets]]
         set clock_name [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_clock_name_from_pin_name $pin_name]

         if {[string compare -nocase $clock_name ""] != 0} {
            if {[regexp -nocase "lvds_clk" $pin_name] || [regexp -nocase "loaden" $pin_name] } {
               remove_clock $clock_name
               set clock_name ""
            }
          }
       }
   } else {
      if {([string compare -nocase $opts(-name) ""] != 0) && ([string compare -nocase $opts(-name) $clock_name])} {

         if {[regexp -nocase "pll_inst\|outclk" $opts(-target)]} {
            remove_clock $clock_name
            set clock_name ""
         }
      }
   }

   if {[string compare -nocase $clock_name ""] == 0} {
      set clock_name $opts(-name)

      create_generated_clock \
         -name $clock_name \
         -source $opts(-source) \
         -multiply_by $multiply_by \
         -divide_by $opts(-divide_by) \
         -phase $opts(-phase) \
         $opts(-target)
   }

   return $clock_name
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_core_full_instance_list {corename} {

   set instance_list [list]

   if {[is_fitter_in_qhd_mode]} {
      set instance_list_pre [design::get_instances -entity $corename]

   } else {
      set instance_list_pre [get_entity_instances $corename]
   }

   foreach instance $instance_list_pre {
      regsub {\|arch$} $instance "" instance_no_arch
      lappend instance_list $instance_no_arch
   }

   if {[ llength $instance_list ] == 0} {
      post_message -type error "The auto-constraining script was not able to detect any instance for core < $corename >"
      post_message -type error "Make sure the core < $corename > is instantiated within another component (wrapper)"
      post_message -type error "and it's not the top-level for your project"
   }

   return $instance_list
}


proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_traverse_fanin_up_to_depth { node_id match_command edge_type results_array_name depth} {
   upvar 1 $results_array_name results

   if {$depth < 0} {
      error "Internal error: Bad timing netlist search depth"
   }
   set fanin_edges [get_node_info -${edge_type}_edges $node_id]
   set number_of_fanin_edges [llength $fanin_edges]
   for {set i 0} {$i != $number_of_fanin_edges} {incr i} {
      set fanin_edge [lindex $fanin_edges $i]
      set fanin_id [get_edge_info -src $fanin_edge]
      if {$match_command == "" || [eval $match_command $fanin_id] != 0} {
         set results($fanin_id) 1
      } elseif {$depth == 0} {
      } else {
         ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_traverse_fanin_up_to_depth $fanin_id $match_command $edge_type results [expr {$depth - 1}]
      }
   }
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_is_node_type_pin { node_id } {
   set node_type [get_node_info -type $node_id]
   if {$node_type == "port"} {
      set result 1
   } else {
      set result 0
   }
   return $result
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_pll_clock_name { clock_id } {
   set clock_name [get_node_info -name $clock_id]

   return $clock_name
}

proc post_sdc_message {msg_type msg} {
   global ::io_only_analysis

   if {($::io_only_analysis == 1) || $::TimeQuestInfo(nameofexecutable) != "quartus_fit"} {
      post_message -type $msg_type $msg
   }
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_names_in_collection { col } {
   set res [list]
   foreach_in_collection node $col {
      lappend res [ get_node_info -name $node ]
   }
   return $res
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_format_3dp { x } {
   return [format %.3f $x]
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_colours { x y } {

   set fcolour [list "black"]
   if {$x < 0} {
      lappend fcolour "red"
   } else {
      lappend fcolour "blue"
   }
   if {$y < 0} {
      lappend fcolour "red"
   } else {
      lappend fcolour "blue"
   }

   return $fcolour
}

proc min { a b } {
   if { $a == "" } {
      return $b
   } elseif { $a < $b } {
      return $a
   } else {
      return $b
   }
}

proc max { a b } {
   if { $a == "" } {
      return $b
   } elseif { $a > $b } {
      return $a
   } else {
      return $b
   }
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_max_in_collection { col attribute } {
   set i 0
   set max 0
   foreach_in_collection path $col {
      if {$i == 0} {
         set max [get_path_info $path -${attribute}]
      } else {
         set temp [get_path_info $path -${attribute}]
         if {$temp > $max} {
            set max $temp
         }
      }
      set i [expr $i + 1]
   }
   return $max
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_min_in_collection { col attribute } {
   set i 0
   set min 0
   foreach_in_collection path $col {
      if {$i == 0} {
         set min [get_path_info $path -${attribute}]
      } else {
         set temp [get_path_info $path -${attribute}]
         if {$temp < $min} {
            set min $temp
         }
      }
      set i [expr $i + 1]
   }
   return $min
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_min_in_collection_to_clock { col attribute clock } {
   set i 0
   set min ERROR
   foreach_in_collection path $col {
      if {[get_clock_info -name [get_path_info $path -to_clock]] == $clock} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_min_in_collection_from_clock { col attribute clock } {
   set i 0
   set min ERROR
   foreach_in_collection path $col {
      if {[get_clock_info -name [get_path_info $path -from_clock]] == $clock} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_min_in_collection_to_name { col attribute name } {
   set i 0
   set min 0
   foreach_in_collection path $col {
      if {[get_node_info -name [get_path_info $path -to]] == $name} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_min_in_collection_from_name { col attribute name } {
   set i 0
   set min 0
   foreach_in_collection path $col {
      if {[get_node_info -name [get_path_info $path -from]] == $name} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_max_in_collection_to_name { col attribute name } {
   set i 0
   set max 0
   foreach_in_collection path $col {
      if {[get_node_info -name [get_path_info $path -to]] == $name} {
         if {$i == 0} {
            set max [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp > $max} {
               set max $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $max
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_max_in_collection_from_name { col attribute name } {
   set i 0
   set max 0
   foreach_in_collection path $col {
      if {[get_node_info -name [get_path_info $path -from]] == $name} {
         if {$i == 0} {
            set max [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp > $max} {
               set max $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $max
}


proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_min_in_collection_to_name2 { col attribute name } {
   set i 0
   set min 0
   foreach_in_collection path $col {
      if {[regexp $name [get_node_info -name [get_path_info $path -to]]]} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_min_in_collection_from_name2 { col attribute name } {
   set i 0
   set min 0
   foreach_in_collection path $col {
      if {[regexp $name [get_node_info -name [get_path_info $path -from]]]} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_max_in_collection_to_name2 { col attribute name } {
   set i 0
   set max 0
   foreach_in_collection path $col {
      if {[regexp $name [get_node_info -name [get_path_info $path -to]]]} {
         if {$i == 0} {
            set max [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp > $max} {
               set max $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $max
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_max_in_collection_from_name2 { col attribute name } {
   set i 0
   set max 0
   foreach_in_collection path $col {
      if {[regexp $name [get_node_info -name [get_path_info $path -from]]]} {
         if {$i == 0} {
            set max [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp > $max} {
               set max $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $max
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_sort_proc {a b} {
   set idxs [list 1 2 0]
   foreach i $idxs {
      set ai [lindex $a $i]
      set bi [lindex $b $i]
      if {$ai > $bi} {
         return 1
      } elseif { $ai < $bi } {
         return -1
      }
   }
   return 0
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_gcd {p q} {
   set p [expr {abs($p)}]
   set q [expr {abs($q)}]
   while {$q != 0} {
      set r [expr {$p % $q}]
      set p $q
      set q $r
   }
   return $p
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_traverse_atom_path {atom_id atom_oport_id path} {
   # Return list of {atom oterm_id} pairs by tracing the atom netlist starting from the given atom_id through the given path
   # Path consists of list of {atom_type fanin|fanout|end <port_type> <-optional>}
   set result [list]
   if {[llength $path] > 0} {
      set path_point [lindex $path 0]
      set atom_type [lindex $path_point 0]
      set next_direction [lindex $path_point 1]
      set port_type [lindex $path_point 2]
      set atom_optional [lindex $path_point 3]
      if {[get_atom_node_info -key type -node $atom_id] == $atom_type} {
         if {$next_direction == "end"} {
            if {[get_atom_port_info -key type -node $atom_id -port_id $atom_oport_id -type oport] == $port_type} {
               lappend result [list $atom_id $atom_oport_id]
            }
         } elseif {$next_direction == "atom"} {
            lappend result [list $atom_id]
         } elseif {$next_direction == "fanin"} {
            set atom_iport [get_atom_iport_by_type -node $atom_id -type $port_type]
            if {$atom_iport != -1} {
               set iport_fanin [get_atom_port_info -key fanin -node $atom_id -port_id $atom_iport -type iport]
               set source_atom [lindex $iport_fanin 0]
               set source_oterm [lindex $iport_fanin 1]
               set result [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_traverse_atom_path $source_atom $source_oterm [lrange $path 1 end]]
            } elseif {$atom_optional == "-optional"} {
               set result [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_traverse_atom_path $atom_id $atom_oport_id [lrange $path 1 end]]
            }
         } elseif {$next_direction == "fanout"} {
            set atom_oport [get_atom_oport_by_type -node $atom_id -type $port_type]
            if {$atom_oport != -1} {
               set oport_fanout [get_atom_port_info -key fanout -node $atom_id -port_id $atom_oport -type oport]
               foreach dest $oport_fanout {
                  set dest_atom [lindex $dest 0]
                  set dest_iterm [lindex $dest 1]
                  set fanout_result_list [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_traverse_atom_path $dest_atom -1 [lrange $path 1 end]]
                  foreach fanout_result $fanout_result_list {
                     if {[lsearch $result $fanout_result] == -1} {
                        lappend result $fanout_result
                     }
                  }
               }
            }
         } else {
            error "Unexpected path"
         }
      } elseif {$atom_optional == "-optional"} {
         set result [ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_traverse_atom_path $atom_id $atom_oport_id [lrange $path 1 end]]
      }
   }
   return $result
}

proc ed_synth_emif_fm_0_altera_emif_arch_fm_191_faapzxy_get_operating_conditions_number {} {
   set cur_operating_condition [get_operating_conditions]
   set counter 0
   foreach_in_collection op [get_available_operating_conditions] {
      if {[string compare $cur_operating_condition $op] == 0} {
         return $counter
      }
      incr counter
   }
   return $counter
}
 13 0 1 / 4 home 7 mustafa 8 projects 15 cva6_intel_fpga 4 cva6 9 corev_apu 5 intel 2 ip 6 io_pll 17 altera_iopll_1931 5 synth 36 io_pll_altera_iopll_1931_saopfla.sdc 6862 # (C) 2001-2024 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file contains the timing constraints for the Altera PLL.
#    * The helper routines are defined in io_pll_altera_iopll_1931_saopfla_pin_map.tcl
#
# NOTE
# ----
# Debug switch. Change to 1 to get more run-time debug information
set debug 0

set script_dir [file dirname [info script]]

source "$script_dir/io_pll_altera_iopll_1931_saopfla_parameters.tcl"
source "$script_dir/io_pll_altera_iopll_1931_saopfla_pin_map.tcl"

####################
#                  #
# GENERAL SETTINGS #
#                  #
####################

# This is a global setting and will apply to the whole design.
# This setting is required for the memory interface to be
# properly constrained.
derive_clock_uncertainty


# All timing requirements will be represented in nanoseconds with up to 3 decimal places of precision
set_time_format -unit ns -decimal_places 3

# Determine if entity names are on
set entity_names_on [ ai_are_entity_names_on ]

if {[catch {load_package atoms
            load_package sdc_ext
            load_package design
            catch {read_atom_netlist} read_atom_netlist_out
            set read_atom_netlist_error [regexp "ERROR" $read_atom_netlist_out]
            } err_loading_packages]} {
    post_message -type error "Failed to load packages required by IOPLL SDC: $err_loading_packages"
}

# This is the main call to the netlist traversal routines
# that will automatically find all pins and registers required
# to apply timing constraints.
# During the fitter, the routines will be called only once
# and cached data will be used in all subsequent calls.



if {[info exists ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_corename_ai_pll_db]} {
    # Clean-up stale content
    unset ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_corename_ai_pll_db
}
if {[catch {ai_initialize_pll_db ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_corename_ai_pll_db} err_initializing_db]} {
    post_message -type warning "Failed to find atom information in IOPLL SDC: $err_initializing_db"
}

# If multiple instances of this core are present in the
# design they will all be constrained through the
# following loop
set instances [ array names ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_corename_ai_pll_db ]
foreach { inst } $instances {
	if { [ info exists pins ] } {
		# Clean-up stale content
		unset pins
	}
	
	# -------------------------------- #
	# -                              - #
	# --- Determine PLL Parameters --- #
	# -                              - #
	# -------------------------------- #
	
	set pll_atoms [get_atom_nodes -matching ${inst}* -type IOPLL]
	set num_pll_inst [get_collection_size $pll_atoms]
	
	if {$num_pll_inst > 1} { 
		# Error condition
		post_message -type error "SDC: More than one PLL atom found with instance name $inst"
	} else {
		# Use IP generated parameters
		if { $debug } {
			post_message -type info "SDC: using IP generated parameter values"
		}
	}

    # These dictionaries hold all the clock information.
    lassign $::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_corename_ai_pll_db($inst) base_clock_data_dict gen_clock_data_dict
	
	# ------------------------ #
	# -                      - #
	# ---REFERENCE CLOCK(s)--- #
	# -                      - #
	# ------------------------ #
    dict for {clock_key info} $base_clock_data_dict {
        dict with info {
            if {$is_fpga_pin && !$exists} {
               create_clock -period $period \
                   -waveform [ list 0 $half_period] \
                   -name $name $port_node_name
            }
        }
    }
	# ------------------------- #
	# -                       - #
	# --- OUTPUT PLL CLOCKS --- #
	# -                       - #
	# ------------------------- #
    dict for {clock_key info} $gen_clock_data_dict {
        dict with info {
            if {[is_post_syn_sta]} {
                if {$is_valid && !$exists} {
                    create_non_virtual_generated_clock_with_master_or_source \
                        $master \
                        $src \
                        $name \
                        $multiply_by \
                        $divide_by \
                        $phase \
                        $duty_cycle \
                        $pin_node_name

                    if {[string match lvds* $clock_key] && [string match *loaden* $pattern] && [dict exists $gen_clock_data_dict $clock_key "through_pin" ] } {
                        set_max_delay_in_fit_or_false_path_in_sta_through_no_warn $through_pin $max_delay
                    }
                } elseif {[is_m_n_cntr $pattern]} {
                    create_virtual_generated_clock_with_master_or_source \
                        $master \
                        $src \
                        $name \
                        $multiply_by \
                        $divide_by \
                        $phase \
                        $duty_cycle
                }
            } else {
                if {$is_valid && !$exists} {
                    create_generated_clock -add \
                        -source $src \
                        -name $name \
                        -multiply_by $multiply_by \
                        -divide_by $divide_by \
                        -phase $phase \
                        -duty_cycle $duty_cycle \
                        $pin_node_name

                    if {[string match lvds* $clock_key] && [string match *loaden* $pattern] && [dict exists $gen_clock_data_dict $clock_key "through_pin" ] } {
                        set_max_delay_in_fit_or_false_path_in_sta_through_no_warn $through_pin $max_delay
                    }
                }
            }
        }
    }

    foreach_in_collection node [get_nodes -no_duplicates -nowarn "${inst}|tennm_pll|dprio_rst_n"] {
        set_false_path -through [get_node_info -name $node]
    }
}
 13 0 1 / 4 home 7 mustafa 8 projects 15 cva6_intel_fpga 4 cva6 9 corev_apu 5 intel 2 ip 6 io_pll 17 altera_iopll_1931 5 synth 50 io_pll_altera_iopll_1931_saopfla_all_ip_params.tcl 51528 # PLL parameters

#USER W A R N I N G !
#USER The PLL parameters are statically defined in this
#USER file at generation time!

set ::pll_corename io_pll_altera_iopll_1931_saopfla

set ::pll_all_ip_params [dict create]

dict set ::pll_all_ip_params gui_device_family "Agilex 7"
dict set ::pll_all_ip_params gui_device_component "AGFB014R24B2E2V"
dict set ::pll_all_ip_params gui_device_speed_grade "2"
dict set ::pll_all_ip_params gui_device_iobank_rev "IO96A_REVB2"
dict set ::pll_all_ip_params gui_debug_mode "false"
dict set ::pll_all_ip_params gui_skip_sdc_generation "false"
dict set ::pll_all_ip_params gui_include_iossm "false"
dict set ::pll_all_ip_params gui_cal_code_hex_file "iossm.hex"
dict set ::pll_all_ip_params gui_parameter_table_hex_file "seq_params_sim.hex"
dict set ::pll_all_ip_params gui_pll_tclk_mux_en "false"
dict set ::pll_all_ip_params gui_pll_tclk_sel "pll_tclk_m_src"
dict set ::pll_all_ip_params gui_pll_vco_freq_band_0 "pll_freq_clk0_band18"
dict set ::pll_all_ip_params gui_pll_vco_freq_band_1 "pll_freq_clk1_band18"
dict set ::pll_all_ip_params gui_pll_freqcal_en "true"
dict set ::pll_all_ip_params gui_pll_freqcal_req_flag "true"
dict set ::pll_all_ip_params gui_cal_converge "false"
dict set ::pll_all_ip_params gui_cal_error "cal_clean"
dict set ::pll_all_ip_params gui_pll_cal_done "false"
dict set ::pll_all_ip_params gui_pll_type "S10_Simple"
dict set ::pll_all_ip_params gui_pll_m_cnt_in_src "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src0 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src1 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src2 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src3 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src4 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src5 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src6 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src7 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src8 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params system_info_device_family "Agilex 7"
dict set ::pll_all_ip_params system_info_device_component "AGFB014R24B2E2V"
dict set ::pll_all_ip_params system_info_device_speed_grade "2"
dict set ::pll_all_ip_params system_part_trait_speed_grade "2"
dict set ::pll_all_ip_params system_part_trait_iobank_rev "IO96A_REVB2"
dict set ::pll_all_ip_params gui_usr_device_speed_grade "1"
dict set ::pll_all_ip_params gui_en_reconf "false"
dict set ::pll_all_ip_params gui_en_iossm_reconf "false"
dict set ::pll_all_ip_params gui_user_base_address "0"
dict set ::pll_all_ip_params gui_en_dps_ports "false"
dict set ::pll_all_ip_params gui_pll_mode "Integer-N PLL"
dict set ::pll_all_ip_params gui_location_type "I/O Bank"
dict set ::pll_all_ip_params gui_use_logical "false"
dict set ::pll_all_ip_params gui_reference_clock_frequency "100.0"
dict set ::pll_all_ip_params gui_reference_clock_frequency_ps "10000.0"
dict set ::pll_all_ip_params gui_use_coreclk "true"
dict set ::pll_all_ip_params gui_refclk_might_change "false"
dict set ::pll_all_ip_params gui_fractional_cout "32"
dict set ::pll_all_ip_params gui_prot_mode "UNUSED"
dict set ::pll_all_ip_params gui_dsm_out_sel "1st_order"
dict set ::pll_all_ip_params gui_use_locked "true"
dict set ::pll_all_ip_params gui_en_adv_params "false"
dict set ::pll_all_ip_params gui_pll_bandwidth_preset "Medium"
dict set ::pll_all_ip_params gui_lock_setting "Low Lock Time"
dict set ::pll_all_ip_params gui_pll_auto_reset "false"
dict set ::pll_all_ip_params gui_en_lvds_ports "Disabled"
dict set ::pll_all_ip_params gui_en_periphery_ports "false"
dict set ::pll_all_ip_params gui_operation_mode "direct"
dict set ::pll_all_ip_params gui_feedback_clock "Global Clock"
dict set ::pll_all_ip_params gui_clock_to_compensate "0"
dict set ::pll_all_ip_params gui_use_NDFB_modes "false"
dict set ::pll_all_ip_params gui_refclk_switch "false"
dict set ::pll_all_ip_params gui_refclk1_frequency "100.0"
dict set ::pll_all_ip_params gui_en_phout_ports "false"
dict set ::pll_all_ip_params gui_phout_division "1"
dict set ::pll_all_ip_params gui_en_extclkout_ports "false"
dict set ::pll_all_ip_params gui_number_of_clocks "5"
dict set ::pll_all_ip_params gui_multiply_factor "25"
dict set ::pll_all_ip_params gui_divide_factor_n "6"
dict set ::pll_all_ip_params gui_frac_multiply_factor "1"
dict set ::pll_all_ip_params gui_fix_vco_frequency "false"
dict set ::pll_all_ip_params gui_fixed_vco_frequency "600.0"
dict set ::pll_all_ip_params gui_fixed_vco_frequency_ps "1667.0"
dict set ::pll_all_ip_params gui_vco_frequency "1250.0"
dict set ::pll_all_ip_params gui_enable_output_counter_cascading "false"
dict set ::pll_all_ip_params gui_mif_gen_options "Generate New MIF File"
dict set ::pll_all_ip_params gui_new_mif_file_path "~/pll.mif"
dict set ::pll_all_ip_params gui_existing_mif_file_path "~/pll.mif"
dict set ::pll_all_ip_params gui_mif_config_name "unnamed"
dict set ::pll_all_ip_params gui_active_clk "false"
dict set ::pll_all_ip_params gui_clk_bad "false"
dict set ::pll_all_ip_params gui_switchover_mode "Automatic Switchover"
dict set ::pll_all_ip_params gui_switchover_delay "0"
dict set ::pll_all_ip_params gui_enable_cascade_out "false"
dict set ::pll_all_ip_params gui_cascade_outclk_index "0"
dict set ::pll_all_ip_params gui_enable_cascade_in "false"
dict set ::pll_all_ip_params gui_enable_permit_cal "false"
dict set ::pll_all_ip_params gui_enable_upstream_out_clk "false"
dict set ::pll_all_ip_params gui_pll_cascading_mode "adjpllin"
dict set ::pll_all_ip_params gui_enable_mif_dps "false"
dict set ::pll_all_ip_params gui_dps_cntr "C0"
dict set ::pll_all_ip_params gui_dps_num "1"
dict set ::pll_all_ip_params gui_dps_dir "Positive"
dict set ::pll_all_ip_params gui_extclkout_0_source "C0"
dict set ::pll_all_ip_params gui_extclkout_1_source "C0"
dict set ::pll_all_ip_params gui_extclkout_source "C0"
dict set ::pll_all_ip_params gui_clock_name_global "false"
dict set ::pll_all_ip_params gui_clock_name_string0 "outclk0"
dict set ::pll_all_ip_params gui_clock_name_string1 "outclk1"
dict set ::pll_all_ip_params gui_clock_name_string2 "outclk2"
dict set ::pll_all_ip_params gui_clock_name_string3 "outclk3"
dict set ::pll_all_ip_params gui_clock_name_string4 "outclk4"
dict set ::pll_all_ip_params gui_clock_name_string5 "outclk5"
dict set ::pll_all_ip_params gui_clock_name_string6 "outclk6"
dict set ::pll_all_ip_params gui_clock_name_string7 "outclk7"
dict set ::pll_all_ip_params gui_clock_name_string8 "outclk8"
dict set ::pll_all_ip_params gui_clock_name_string9 "outclk9"
dict set ::pll_all_ip_params gui_clock_name_string10 "outclk10"
dict set ::pll_all_ip_params gui_clock_name_string11 "outclk11"
dict set ::pll_all_ip_params gui_clock_name_string12 "outclk12"
dict set ::pll_all_ip_params gui_clock_name_string13 "outclk13"
dict set ::pll_all_ip_params gui_clock_name_string14 "outclk14"
dict set ::pll_all_ip_params gui_clock_name_string15 "outclk15"
dict set ::pll_all_ip_params gui_clock_name_string16 "outclk16"
dict set ::pll_all_ip_params gui_clock_name_string17 "outclk17"
dict set ::pll_all_ip_params gui_divide_factor_c0 "1"
dict set ::pll_all_ip_params gui_divide_factor_c1 "25"
dict set ::pll_all_ip_params gui_divide_factor_c2 "25"
dict set ::pll_all_ip_params gui_divide_factor_c3 "6"
dict set ::pll_all_ip_params gui_divide_factor_c4 "6"
dict set ::pll_all_ip_params gui_divide_factor_c5 "6"
dict set ::pll_all_ip_params gui_divide_factor_c6 "6"
dict set ::pll_all_ip_params gui_divide_factor_c7 "6"
dict set ::pll_all_ip_params gui_divide_factor_c8 "6"
dict set ::pll_all_ip_params gui_divide_factor_c9 "6"
dict set ::pll_all_ip_params gui_divide_factor_c10 "6"
dict set ::pll_all_ip_params gui_divide_factor_c11 "6"
dict set ::pll_all_ip_params gui_divide_factor_c12 "6"
dict set ::pll_all_ip_params gui_divide_factor_c13 "6"
dict set ::pll_all_ip_params gui_divide_factor_c14 "6"
dict set ::pll_all_ip_params gui_divide_factor_c15 "6"
dict set ::pll_all_ip_params gui_divide_factor_c16 "6"
dict set ::pll_all_ip_params gui_divide_factor_c17 "6"
dict set ::pll_all_ip_params gui_cascade_counter0 "false"
dict set ::pll_all_ip_params gui_cascade_counter1 "false"
dict set ::pll_all_ip_params gui_cascade_counter2 "false"
dict set ::pll_all_ip_params gui_cascade_counter3 "false"
dict set ::pll_all_ip_params gui_cascade_counter4 "false"
dict set ::pll_all_ip_params gui_cascade_counter5 "false"
dict set ::pll_all_ip_params gui_cascade_counter6 "false"
dict set ::pll_all_ip_params gui_cascade_counter7 "false"
dict set ::pll_all_ip_params gui_cascade_counter8 "false"
dict set ::pll_all_ip_params gui_cascade_counter9 "false"
dict set ::pll_all_ip_params gui_cascade_counter10 "false"
dict set ::pll_all_ip_params gui_cascade_counter11 "false"
dict set ::pll_all_ip_params gui_cascade_counter12 "false"
dict set ::pll_all_ip_params gui_cascade_counter13 "false"
dict set ::pll_all_ip_params gui_cascade_counter14 "false"
dict set ::pll_all_ip_params gui_cascade_counter15 "false"
dict set ::pll_all_ip_params gui_cascade_counter16 "false"
dict set ::pll_all_ip_params gui_cascade_counter17 "false"
dict set ::pll_all_ip_params gui_output_clock_frequency0 "50.0"
dict set ::pll_all_ip_params gui_output_clock_frequency1 "125.0"
dict set ::pll_all_ip_params gui_output_clock_frequency2 "200.0"
dict set ::pll_all_ip_params gui_output_clock_frequency3 "125.0"
dict set ::pll_all_ip_params gui_output_clock_frequency4 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency5 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency6 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency7 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency8 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency9 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency10 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency11 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency12 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency13 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency14 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency15 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency16 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency17 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps0 "20000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps1 "8000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps2 "5000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps3 "8000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps4 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps5 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps6 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps7 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps8 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps9 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps10 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps11 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps12 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps13 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps14 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps15 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps16 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps17 "10000.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency0 "50.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency1 "125.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency2 "200.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency3 "125.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency4 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency5 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency6 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency7 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency8 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency9 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency10 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency11 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency12 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency13 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency14 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency15 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency16 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency17 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range0 "49.758454 49.777778 49.794239 50.0 50.205761 50.222222"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range1 "121.428571 122.222222 122.727273 125.0 127.272727 127.777778"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range2 "166.666667 178.571429 187.5 200.0 208.333333 250.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range3 "90.909091 100.0 111.111111 125.0 142.857143 166.666667"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range4 "76.923077 83.333333 90.909091 100.0 111.111111 125.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range5 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range6 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range7 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range8 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range9 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range10 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range11 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range12 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range13 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range14 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range15 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range16 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range17 "100.0"
dict set ::pll_all_ip_params gui_ps_units0 "ps"
dict set ::pll_all_ip_params gui_ps_units1 "ps"
dict set ::pll_all_ip_params gui_ps_units2 "ps"
dict set ::pll_all_ip_params gui_ps_units3 "degrees"
dict set ::pll_all_ip_params gui_ps_units4 "ps"
dict set ::pll_all_ip_params gui_ps_units5 "ps"
dict set ::pll_all_ip_params gui_ps_units6 "ps"
dict set ::pll_all_ip_params gui_ps_units7 "ps"
dict set ::pll_all_ip_params gui_ps_units8 "ps"
dict set ::pll_all_ip_params gui_ps_units9 "ps"
dict set ::pll_all_ip_params gui_ps_units10 "ps"
dict set ::pll_all_ip_params gui_ps_units11 "ps"
dict set ::pll_all_ip_params gui_ps_units12 "ps"
dict set ::pll_all_ip_params gui_ps_units13 "ps"
dict set ::pll_all_ip_params gui_ps_units14 "ps"
dict set ::pll_all_ip_params gui_ps_units15 "ps"
dict set ::pll_all_ip_params gui_ps_units16 "ps"
dict set ::pll_all_ip_params gui_ps_units17 "ps"
dict set ::pll_all_ip_params gui_phase_shift0 "0.0"
dict set ::pll_all_ip_params gui_phase_shift1 "0.0"
dict set ::pll_all_ip_params gui_phase_shift2 "0.0"
dict set ::pll_all_ip_params gui_phase_shift3 "0.0"
dict set ::pll_all_ip_params gui_phase_shift4 "0.0"
dict set ::pll_all_ip_params gui_phase_shift5 "0.0"
dict set ::pll_all_ip_params gui_phase_shift6 "0.0"
dict set ::pll_all_ip_params gui_phase_shift7 "0.0"
dict set ::pll_all_ip_params gui_phase_shift8 "0.0"
dict set ::pll_all_ip_params gui_phase_shift9 "0.0"
dict set ::pll_all_ip_params gui_phase_shift10 "0.0"
dict set ::pll_all_ip_params gui_phase_shift11 "0.0"
dict set ::pll_all_ip_params gui_phase_shift12 "0.0"
dict set ::pll_all_ip_params gui_phase_shift13 "0.0"
dict set ::pll_all_ip_params gui_phase_shift14 "0.0"
dict set ::pll_all_ip_params gui_phase_shift15 "0.0"
dict set ::pll_all_ip_params gui_phase_shift16 "0.0"
dict set ::pll_all_ip_params gui_phase_shift17 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg0 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg1 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg2 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg3 "90.0"
dict set ::pll_all_ip_params gui_phase_shift_deg4 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg5 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg6 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg7 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg8 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg9 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg10 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg11 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg12 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg13 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg14 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg15 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg16 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg17 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift0 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift1 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift2 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift3 "2000.0"
dict set ::pll_all_ip_params gui_actual_phase_shift4 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift5 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift6 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift7 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift8 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift9 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift10 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift11 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift12 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift13 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift14 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift15 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift16 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift17 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range0 "0.0 125.0 250.0 375.0 500.0 625.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range1 "0.0 125.0 250.0 375.0 500.0 625.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range2 "0.0 125.0 250.0 375.0 500.0 625.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range3 "1625.0 1750.0 1875.0 2000.0 2125.0 2250.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range4 "0.0 125.0 250.0 375.0 500.0 625.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range5 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range6 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range7 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range8 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range9 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range10 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range11 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range12 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range13 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range14 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range15 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range16 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range17 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg0 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg1 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg2 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg3 "90.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg4 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg5 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg6 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg7 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg8 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg9 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg10 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg11 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg12 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg13 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg14 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg15 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg16 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg17 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range0 "0.0 2.2 4.5 6.8 9.0 11.2"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range1 "0.0 5.6 11.2 16.9 22.5 28.1"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range2 "0.0 9.0 18.0 27.0 36.0 45.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range3 "73.1 78.8 84.4 90.0 95.6 101.2"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range4 "0.0 4.5 9.0 13.5 18.0 22.5"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range5 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range6 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range7 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range8 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range9 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range10 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range11 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range12 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range13 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range14 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range15 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range16 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range17 "0.0"
dict set ::pll_all_ip_params gui_duty_cycle0 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle1 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle2 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle3 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle4 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle5 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle6 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle7 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle8 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle9 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle10 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle11 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle12 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle13 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle14 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle15 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle16 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle17 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle0 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle1 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle2 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle3 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle4 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle5 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle6 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle7 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle8 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle9 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle10 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle11 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle12 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle13 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle14 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle15 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle16 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle17 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range0 "42.5 45.0 47.5 50.0 52.5 55.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range1 "31.25 37.5 43.75 50.0 56.25 62.5"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range2 "20.0 30.0 40.0 50.0 60.0 70.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range3 "31.25 37.5 43.75 50.0 56.25 62.5"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range4 "35.0 40.0 45.0 50.0 55.0 60.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range5 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range6 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range7 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range8 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range9 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range10 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range11 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range12 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range13 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range14 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range15 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range16 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range17 "50.0"
dict set ::pll_all_ip_params gui_simulation_type "false"
dict set ::pll_all_ip_params parameterTable_names "{M-Counter Divide Setting} {N-Counter Divide Setting} {VCO Frequency} {C-Counter-0 Divide Setting} {C-Counter-1 Divide Setting} {C-Counter-2 Divide Setting} {C-Counter-3 Divide Setting} {C-Counter-4 Divide Setting} {C-Counter-5 Divide Setting} {C-Counter-6 Divide Setting} {C-Counter-7 Divide Setting} {C-Counter-8 Divide Setting} {PLL Auto Reset} {M-Counter Hi Divide} {M-Counter Lo Divide} {M-Counter Even Duty Enable} {M-Counter Bypass Enable} {N-Counter Hi Divide} {N-Counter Lo Divide} {N-Counter Even Duty Enable} {N-Counter Bypass Enable} {C-Counter-0 Hi Divide} {C-Counter-1 Hi Divide} {C-Counter-2 Hi Divide} {C-Counter-3 Hi Divide} {C-Counter-4 Hi Divide} {C-Counter-5 Hi Divide} {C-Counter-6 Hi Divide} {C-Counter-7 Hi Divide} {C-Counter-8 Hi Divide} {C-Counter-0 Lo Divide} {C-Counter-1 Lo Divide} {C-Counter-2 Lo Divide} {C-Counter-3 Lo Divide} {C-Counter-4 Lo Divide} {C-Counter-5 Lo Divide} {C-Counter-6 Lo Divide} {C-Counter-7 Lo Divide} {C-Counter-8 Lo Divide} {C-Counter-0 Even Duty Enable} {C-Counter-1 Even Duty Enable} {C-Counter-2 Even Duty Enable} {C-Counter-3 Even Duty Enable} {C-Counter-4 Even Duty Enable} {C-Counter-5 Even Duty Enable} {C-Counter-6 Even Duty Enable} {C-Counter-7 Even Duty Enable} {C-Counter-8 Even Duty Enable} {C-Counter-0 Bypass Enable} {C-Counter-1 Bypass Enable} {C-Counter-2 Bypass Enable} {C-Counter-3 Bypass Enable} {C-Counter-4 Bypass Enable} {C-Counter-5 Bypass Enable} {C-Counter-6 Bypass Enable} {C-Counter-7 Bypass Enable} {C-Counter-8 Bypass Enable} {C-Counter-0 Preset} {C-Counter-1 Preset} {C-Counter-2 Preset} {C-Counter-3 Preset} {C-Counter-4 Preset} {C-Counter-5 Preset} {C-Counter-6 Preset} {C-Counter-7 Preset} {C-Counter-8 Preset} {C-Counter-0 Phase Mux Preset} {C-Counter-1 Phase Mux Preset} {C-Counter-2 Phase Mux Preset} {C-Counter-3 Phase Mux Preset} {C-Counter-4 Phase Mux Preset} {C-Counter-5 Phase Mux Preset} {C-Counter-6 Phase Mux Preset} {C-Counter-7 Phase Mux Preset} {C-Counter-8 Phase Mux Preset} {Charge Pump Current} {Bandwidth Control}"
dict set ::pll_all_ip_params parameterTable_values "10 1 {1000.0 MHz} 1 20 8 5 8 10 1 1 1 false 5 5 false false 256 256 false true 256 10 4 3 4 5 256 256 256 256 10 4 2 4 5 256 256 256 false false false true false false false false false true false false false false false true true true 1 1 1 1 3 1 1 1 1 0 0 0 0 0 0 0 0 0 pll_cp_setting5 pll_bw_res_setting3"
dict set ::pll_all_ip_params mifTable_names "{The MIF file specified does not yet exist}"
dict set ::pll_all_ip_params pll_m_cnt_basic "1"
dict set ::pll_all_ip_params pll_m_cnt "1"
dict set ::pll_all_ip_params prot_mode "BASIC"
dict set ::pll_all_ip_params protocol_mode "PROTOCOL_MODE_BASIC"
dict set ::pll_all_ip_params m_cnt_hi_div "5"
dict set ::pll_all_ip_params eff_m_cnt "1"
dict set ::pll_all_ip_params multiply_factor "10"
dict set ::pll_all_ip_params use_core_refclk "true"
dict set ::pll_all_ip_params m_cnt_lo_div "5"
dict set ::pll_all_ip_params n_cnt_hi_div "256"
dict set ::pll_all_ip_params n_cnt_lo_div "256"
dict set ::pll_all_ip_params m_cnt_bypass_en "false"
dict set ::pll_all_ip_params n_cnt_bypass_en "true"
dict set ::pll_all_ip_params m_cnt_odd_div_duty_en "false"
dict set ::pll_all_ip_params n_cnt_odd_div_duty_en "false"
dict set ::pll_all_ip_params pll_vco_div "1"
dict set ::pll_all_ip_params pll_cp_current "pll_cp_setting5"
dict set ::pll_all_ip_params pll_bwctrl "pll_bw_res_setting3"
dict set ::pll_all_ip_params pll_ripplecap_ctrl "pll_ripplecap_setting1"
dict set ::pll_all_ip_params pll_fractional_division "1"
dict set ::pll_all_ip_params fractional_vco_multiplier "false"
dict set ::pll_all_ip_params reference_clock_frequency "100.0 MHz"
dict set ::pll_all_ip_params pll_fractional_cout "1"
dict set ::pll_all_ip_params pll_dsm_out_sel "1st_order"
dict set ::pll_all_ip_params operation_mode "direct"
dict set ::pll_all_ip_params number_of_clocks "5"
dict set ::pll_all_ip_params number_of_outclks "5"
dict set ::pll_all_ip_params pll_vcoph_div "1"
dict set ::pll_all_ip_params pll_type "TOP_BOTTOM"
dict set ::pll_all_ip_params pll_subtype "General"
dict set ::pll_all_ip_params pll_output_clk_frequency "1000.0 MHz"
dict set ::pll_all_ip_params pll_pfd_frequency "100.0 MHz"
dict set ::pll_all_ip_params mimic_fbclk_type "gclk"
dict set ::pll_all_ip_params pll_bw_sel "mid_bw"
dict set ::pll_all_ip_params pll_slf_rst "false"
dict set ::pll_all_ip_params pll_fbclk_mux_1 "pll_fbclk_mux_1_glb"
dict set ::pll_all_ip_params pll_fbclk_mux_2 "pll_fbclk_mux_2_m_cnt"
dict set ::pll_all_ip_params pll_m_cnt_in_src "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params pll_clkin_0_src "coreclkin"
dict set ::pll_all_ip_params refclk1_frequency "0 MHz"
dict set ::pll_all_ip_params pll_clk_loss_sw_en "false"
dict set ::pll_all_ip_params pll_manu_clk_sw_en "false"
dict set ::pll_all_ip_params pll_auto_clk_sw_en "false"
dict set ::pll_all_ip_params pll_clkin_1_src "ioclkin_0"
dict set ::pll_all_ip_params pll_clk_sw_dly "0"
dict set ::pll_all_ip_params pll_extclk_0_cnt_src "pll_extclk_cnt_src_vss"
dict set ::pll_all_ip_params pll_extclk_1_cnt_src "pll_extclk_cnt_src_vss"
dict set ::pll_all_ip_params pll_lock_fltr_cfg "100"
dict set ::pll_all_ip_params pll_unlock_fltr_cfg "2"
dict set ::pll_all_ip_params lock_mode "low_lock_time"
dict set ::pll_all_ip_params clock_to_compensate "1"
dict set ::pll_all_ip_params clock_name_global "false"
dict set ::pll_all_ip_params pll_freqcal_en "true"
dict set ::pll_all_ip_params pll_defer_cal_user_mode "true"
dict set ::pll_all_ip_params dprio_interface_sel "3"
dict set ::pll_all_ip_params merging_permitted "false"
dict set ::pll_all_ip_params bandwidth_mode "BANDWIDTH_MODE_AUTO"
dict set ::pll_all_ip_params compensation_clk_source "COMPENSATION_CLK_SOURCE_UNUSED"
dict set ::pll_all_ip_params compensation_mode "COMPENSATION_MODE_DIRECT"
dict set ::pll_all_ip_params cascade_mode "CASCADE_MODE_STANDALONE"
dict set ::pll_all_ip_params fb_clk_delay "0"
dict set ::pll_all_ip_params fb_clk_fractional_div_den "1"
dict set ::pll_all_ip_params fb_clk_fractional_div_num "1"
dict set ::pll_all_ip_params fb_clk_fractional_div_value "1"
dict set ::pll_all_ip_params fb_clk_m_div "0"
dict set ::pll_all_ip_params out_clk_cascading_source "OUT_CLK_CASCADING_SOURCE_UNUSED"
dict set ::pll_all_ip_params out_clk_external_0_source "OUT_CLK_EXTERNAL_0_SOURCE_UNUSED"
dict set ::pll_all_ip_params out_clk_external_1_source "OUT_CLK_EXTERNAL_1_SOURCE_UNUSED"
dict set ::pll_all_ip_params out_clk_periph_0_delay "0"
dict set ::pll_all_ip_params out_clk_periph_0_en "true"
dict set ::pll_all_ip_params out_clk_periph_1_delay "0"
dict set ::pll_all_ip_params out_clk_periph_1_en "true"
dict set ::pll_all_ip_params ref_clk_delay "0"
dict set ::pll_all_ip_params ref_clk_n_div "1"
dict set ::pll_all_ip_params set_dutycycle "SET_DUTYCYCLE_FRACTION"
dict set ::pll_all_ip_params set_fractional "SET_FRACTIONAL_FRACTION"
dict set ::pll_all_ip_params set_freq "SET_FREQ_DIVISION"
dict set ::pll_all_ip_params set_phase "SET_PHASE_NUM_SHIFTS"
dict set ::pll_all_ip_params pfd_clk_freq "100000000"
dict set ::pll_all_ip_params vco_clk_freq "1000000000"
dict set ::pll_all_ip_params c_cnt_hi_div0 "256"
dict set ::pll_all_ip_params c_cnt_hi_div1 "10"
dict set ::pll_all_ip_params c_cnt_hi_div2 "4"
dict set ::pll_all_ip_params c_cnt_hi_div3 "3"
dict set ::pll_all_ip_params c_cnt_hi_div4 "4"
dict set ::pll_all_ip_params c_cnt_hi_div5 "5"
dict set ::pll_all_ip_params c_cnt_hi_div6 "256"
dict set ::pll_all_ip_params c_cnt_hi_div7 "256"
dict set ::pll_all_ip_params c_cnt_hi_div8 "256"
dict set ::pll_all_ip_params c_cnt_hi_div9 "256"
dict set ::pll_all_ip_params c_cnt_hi_div10 "1"
dict set ::pll_all_ip_params c_cnt_hi_div11 "1"
dict set ::pll_all_ip_params c_cnt_hi_div12 "1"
dict set ::pll_all_ip_params c_cnt_hi_div13 "1"
dict set ::pll_all_ip_params c_cnt_hi_div14 "1"
dict set ::pll_all_ip_params c_cnt_hi_div15 "1"
dict set ::pll_all_ip_params c_cnt_hi_div16 "1"
dict set ::pll_all_ip_params c_cnt_hi_div17 "1"
dict set ::pll_all_ip_params c_cnt_lo_div0 "256"
dict set ::pll_all_ip_params c_cnt_lo_div1 "10"
dict set ::pll_all_ip_params c_cnt_lo_div2 "4"
dict set ::pll_all_ip_params c_cnt_lo_div3 "2"
dict set ::pll_all_ip_params c_cnt_lo_div4 "4"
dict set ::pll_all_ip_params c_cnt_lo_div5 "5"
dict set ::pll_all_ip_params c_cnt_lo_div6 "256"
dict set ::pll_all_ip_params c_cnt_lo_div7 "256"
dict set ::pll_all_ip_params c_cnt_lo_div8 "256"
dict set ::pll_all_ip_params c_cnt_lo_div9 "256"
dict set ::pll_all_ip_params c_cnt_lo_div10 "1"
dict set ::pll_all_ip_params c_cnt_lo_div11 "1"
dict set ::pll_all_ip_params c_cnt_lo_div12 "1"
dict set ::pll_all_ip_params c_cnt_lo_div13 "1"
dict set ::pll_all_ip_params c_cnt_lo_div14 "1"
dict set ::pll_all_ip_params c_cnt_lo_div15 "1"
dict set ::pll_all_ip_params c_cnt_lo_div16 "1"
dict set ::pll_all_ip_params c_cnt_lo_div17 "1"
dict set ::pll_all_ip_params c_cnt_prst0 "1"
dict set ::pll_all_ip_params c_cnt_prst1 "1"
dict set ::pll_all_ip_params c_cnt_prst2 "1"
dict set ::pll_all_ip_params c_cnt_prst3 "1"
dict set ::pll_all_ip_params c_cnt_prst4 "3"
dict set ::pll_all_ip_params c_cnt_prst5 "1"
dict set ::pll_all_ip_params c_cnt_prst6 "1"
dict set ::pll_all_ip_params c_cnt_prst7 "1"
dict set ::pll_all_ip_params c_cnt_prst8 "1"
dict set ::pll_all_ip_params c_cnt_prst9 "1"
dict set ::pll_all_ip_params c_cnt_prst10 "1"
dict set ::pll_all_ip_params c_cnt_prst11 "1"
dict set ::pll_all_ip_params c_cnt_prst12 "1"
dict set ::pll_all_ip_params c_cnt_prst13 "1"
dict set ::pll_all_ip_params c_cnt_prst14 "1"
dict set ::pll_all_ip_params c_cnt_prst15 "1"
dict set ::pll_all_ip_params c_cnt_prst16 "1"
dict set ::pll_all_ip_params c_cnt_prst17 "1"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst0 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst1 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst2 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst3 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst4 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst5 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst6 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst7 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst8 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst9 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst10 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst11 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst12 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst13 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst14 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst15 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst16 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst17 "0"
dict set ::pll_all_ip_params c_cnt_in_src0 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src1 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src2 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src3 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src4 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src5 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src6 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src7 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src8 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src9 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src10 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src11 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src12 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src13 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src14 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src15 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src16 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src17 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_bypass_en0 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en1 "false"
dict set ::pll_all_ip_params c_cnt_bypass_en2 "false"
dict set ::pll_all_ip_params c_cnt_bypass_en3 "false"
dict set ::pll_all_ip_params c_cnt_bypass_en4 "false"
dict set ::pll_all_ip_params c_cnt_bypass_en5 "false"
dict set ::pll_all_ip_params c_cnt_bypass_en6 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en7 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en8 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en9 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en10 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en11 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en12 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en13 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en14 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en15 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en16 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en17 "true"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en0 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en1 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en2 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en3 "true"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en4 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en5 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en6 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en7 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en8 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en9 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en10 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en11 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en12 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en13 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en14 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en15 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en16 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en17 "false"
dict set ::pll_all_ip_params output_clock_frequency0 "0 ps"
dict set ::pll_all_ip_params output_clock_frequency1 "50.0 MHz"
dict set ::pll_all_ip_params output_clock_frequency2 "125.0 MHz"
dict set ::pll_all_ip_params output_clock_frequency3 "200.0 MHz"
dict set ::pll_all_ip_params output_clock_frequency4 "125.0 MHz"
dict set ::pll_all_ip_params output_clock_frequency5 "100.0 MHz"
dict set ::pll_all_ip_params output_clock_frequency6 "0 ps"
dict set ::pll_all_ip_params output_clock_frequency7 "0 ps"
dict set ::pll_all_ip_params output_clock_frequency8 "0 ps"
dict set ::pll_all_ip_params output_clock_frequency9 "0 ps"
dict set ::pll_all_ip_params output_clock_frequency10 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency11 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency12 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency13 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency14 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency15 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency16 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency17 "0 MHz"
dict set ::pll_all_ip_params phase_shift0 "0 ps"
dict set ::pll_all_ip_params phase_shift1 "0 ps"
dict set ::pll_all_ip_params phase_shift2 "0 ps"
dict set ::pll_all_ip_params phase_shift3 "0 ps"
dict set ::pll_all_ip_params phase_shift4 "2000 ps"
dict set ::pll_all_ip_params phase_shift5 "0 ps"
dict set ::pll_all_ip_params phase_shift6 "0 ps"
dict set ::pll_all_ip_params phase_shift7 "0 ps"
dict set ::pll_all_ip_params phase_shift8 "0 ps"
dict set ::pll_all_ip_params phase_shift9 "0 ps"
dict set ::pll_all_ip_params phase_shift10 "0 ps"
dict set ::pll_all_ip_params phase_shift11 "0 ps"
dict set ::pll_all_ip_params phase_shift12 "0 ps"
dict set ::pll_all_ip_params phase_shift13 "0 ps"
dict set ::pll_all_ip_params phase_shift14 "0 ps"
dict set ::pll_all_ip_params phase_shift15 "0 ps"
dict set ::pll_all_ip_params phase_shift16 "0 ps"
dict set ::pll_all_ip_params phase_shift17 "0 ps"
dict set ::pll_all_ip_params duty_cycle0 "50"
dict set ::pll_all_ip_params duty_cycle1 "50"
dict set ::pll_all_ip_params duty_cycle2 "50"
dict set ::pll_all_ip_params duty_cycle3 "50"
dict set ::pll_all_ip_params duty_cycle4 "50"
dict set ::pll_all_ip_params duty_cycle5 "50"
dict set ::pll_all_ip_params duty_cycle6 "50"
dict set ::pll_all_ip_params duty_cycle7 "50"
dict set ::pll_all_ip_params duty_cycle8 "50"
dict set ::pll_all_ip_params duty_cycle9 "50"
dict set ::pll_all_ip_params duty_cycle10 "50"
dict set ::pll_all_ip_params duty_cycle11 "50"
dict set ::pll_all_ip_params duty_cycle12 "50"
dict set ::pll_all_ip_params duty_cycle13 "50"
dict set ::pll_all_ip_params duty_cycle14 "50"
dict set ::pll_all_ip_params duty_cycle15 "50"
dict set ::pll_all_ip_params duty_cycle16 "50"
dict set ::pll_all_ip_params duty_cycle17 "50"
dict set ::pll_all_ip_params clock_name_1 "outclk0"
dict set ::pll_all_ip_params clock_name_2 "outclk1"
dict set ::pll_all_ip_params clock_name_3 "outclk2"
dict set ::pll_all_ip_params clock_name_4 "outclk3"
dict set ::pll_all_ip_params clock_name_5 "outclk4"
dict set ::pll_all_ip_params clock_name_global_0 "false"
dict set ::pll_all_ip_params clock_name_global_1 "false"
dict set ::pll_all_ip_params clock_name_global_2 "false"
dict set ::pll_all_ip_params clock_name_global_3 "false"
dict set ::pll_all_ip_params clock_name_global_4 "false"
dict set ::pll_all_ip_params clock_name_global_5 "false"
dict set ::pll_all_ip_params clock_name_global_6 "false"
dict set ::pll_all_ip_params clock_name_global_7 "false"
dict set ::pll_all_ip_params clock_name_global_8 "false"
dict set ::pll_all_ip_params divide_factor0 "1"
dict set ::pll_all_ip_params divide_factor1 "1"
dict set ::pll_all_ip_params divide_factor2 "1"
dict set ::pll_all_ip_params divide_factor3 "1"
dict set ::pll_all_ip_params divide_factor4 "1"
dict set ::pll_all_ip_params divide_factor5 "1"
dict set ::pll_all_ip_params divide_factor6 "1"
dict set ::pll_all_ip_params divide_factor7 "1"
dict set ::pll_all_ip_params divide_factor8 "1"
dict set ::pll_all_ip_params out_clk_0_c_div "1"
dict set ::pll_all_ip_params out_clk_1_c_div "1"
dict set ::pll_all_ip_params out_clk_2_c_div "1"
dict set ::pll_all_ip_params out_clk_3_c_div "1"
dict set ::pll_all_ip_params out_clk_4_c_div "1"
dict set ::pll_all_ip_params out_clk_5_c_div "1"
dict set ::pll_all_ip_params out_clk_6_c_div "1"
dict set ::pll_all_ip_params out_clk_0_core_en "true"
dict set ::pll_all_ip_params out_clk_1_core_en "true"
dict set ::pll_all_ip_params out_clk_2_core_en "true"
dict set ::pll_all_ip_params out_clk_3_core_en "true"
dict set ::pll_all_ip_params out_clk_4_core_en "true"
dict set ::pll_all_ip_params out_clk_5_core_en "true"
dict set ::pll_all_ip_params out_clk_6_core_en "true"
dict set ::pll_all_ip_params out_clk_0_delay "0"
dict set ::pll_all_ip_params out_clk_1_delay "0"
dict set ::pll_all_ip_params out_clk_2_delay "0"
dict set ::pll_all_ip_params out_clk_3_delay "0"
dict set ::pll_all_ip_params out_clk_4_delay "0"
dict set ::pll_all_ip_params out_clk_5_delay "0"
dict set ::pll_all_ip_params out_clk_6_delay "0"
dict set ::pll_all_ip_params out_clk_0_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_1_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_2_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_3_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_4_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_5_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_6_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_0_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_1_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_2_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_3_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_4_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_5_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_6_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_0_phase_shifts "0"
dict set ::pll_all_ip_params out_clk_1_phase_shifts "0"
dict set ::pll_all_ip_params out_clk_2_phase_shifts "0"
dict set ::pll_all_ip_params out_clk_3_phase_shifts "0"
dict set ::pll_all_ip_params out_clk_4_phase_shifts "0"
dict set ::pll_all_ip_params out_clk_5_phase_shifts "0"
dict set ::pll_all_ip_params out_clk_6_phase_shifts "0"
dict set ::pll_all_ip_params ref_clk_0_freq "100000000"
dict set ::pll_all_ip_params ref_clk_1_freq "100000000"
dict set ::pll_all_ip_params out_clk_0_freq "1000000000"
dict set ::pll_all_ip_params out_clk_1_freq "1000000000"
dict set ::pll_all_ip_params out_clk_2_freq "1000000000"
dict set ::pll_all_ip_params out_clk_3_freq "1000000000"
dict set ::pll_all_ip_params out_clk_4_freq "1000000000"
dict set ::pll_all_ip_params out_clk_5_freq "1000000000"
dict set ::pll_all_ip_params out_clk_6_freq "1000000000"
dict set ::pll_all_ip_params out_clk_0_phase_ps "1000000000"
dict set ::pll_all_ip_params out_clk_1_phase_ps "1000000000"
dict set ::pll_all_ip_params out_clk_2_phase_ps "1000000000"
dict set ::pll_all_ip_params out_clk_3_phase_ps "1000000000"
dict set ::pll_all_ip_params out_clk_4_phase_ps "1000000000"
dict set ::pll_all_ip_params out_clk_5_phase_ps "1000000000"
dict set ::pll_all_ip_params out_clk_6_phase_ps "1000000000"
dict set ::pll_all_ip_params pll_tclk_mux_en "false"
dict set ::pll_all_ip_params pll_tclk_sel "pll_tclk_m_src"
dict set ::pll_all_ip_params pll_vco_freq_band_0 "pll_freq_clk0_band18"
dict set ::pll_all_ip_params pll_vco_freq_band_1 "pll_freq_clk1_band18"
dict set ::pll_all_ip_params pll_freqcal_req_flag "true"
dict set ::pll_all_ip_params cal_converge "false"
dict set ::pll_all_ip_params cal_error "cal_clean"
dict set ::pll_all_ip_params pll_cal_done "false"
dict set ::pll_all_ip_params include_iossm "false"
dict set ::pll_all_ip_params cal_code_hex_file "iossm.hex"
dict set ::pll_all_ip_params parameter_table_hex_file "seq_params_sim.hex"
dict set ::pll_all_ip_params iossm_nios_sim_clk_period_ps "1333"
dict set ::pll_all_ip_params hp_number_of_family_allowable_clocks "9"
dict set ::pll_all_ip_params hp_previous_num_clocks "1"
dict set ::pll_all_ip_params hp_actual_vco_frequency_fp "600.0"
dict set ::pll_all_ip_params hp_qsys_scripting_mode "false"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp0 "50.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp1 "125.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp2 "200.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp3 "125.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp4 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp5 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp6 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp7 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp8 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp9 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp10 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp11 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp12 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp13 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp14 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp15 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp16 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp17 "100.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp0 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp1 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp2 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp3 "2000.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp4 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp5 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp6 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp7 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp8 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp9 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp10 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp11 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp12 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp13 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp14 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp15 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp16 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp17 "0.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp0 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp1 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp2 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp3 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp4 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp5 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp6 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp7 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp8 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp9 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp10 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp11 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp12 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp13 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp14 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp15 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp16 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp17 "50.0"
 13 0 1 / 4 home 7 mustafa 8 projects 15 cva6_intel_fpga 4 cva6 9 corev_apu 5 intel 2 ip 6 io_pll 17 altera_iopll_1931 5 synth 47 io_pll_altera_iopll_1931_saopfla_parameters.tcl 10925 # PLL Parameters

#USER W A R N I N G !
#USER The PLL parameters are statically defined in this
#USER file at generation time!
#USER To ensure timing constraints and timing reports are correct, when you make 
#USER any changes to the PLL component using the Qsys,
#USER apply those changes to the PLL parameters in this file

set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_corename io_pll_altera_iopll_1931_saopfla

set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_base_clock_data [dict create]
set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data [dict create]
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_base_clock_data refclk pattern __inst_name__|tennm_pll|core_refclk
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_base_clock_data refclk node_type pin
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_base_clock_data refclk pin_id ""
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_base_clock_data refclk pin_node_name ""
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_base_clock_data refclk port_id ""
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_base_clock_data refclk port_node_name ""
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_base_clock_data refclk is_fpga_pin false
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_base_clock_data refclk is_main_refclk true
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_base_clock_data refclk exists false
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_base_clock_data refclk name "__inst_name___refclk"
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_base_clock_data refclk period 10.000
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_base_clock_data refclk half_period 5.000
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data n_cnt_clock pattern __inst_name__|tennm_pll~ncntr_reg
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data n_cnt_clock node_type register
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data n_cnt_clock pin_id ""
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data n_cnt_clock pin_node_name ""
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data n_cnt_clock is_valid false
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data n_cnt_clock exists false
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data n_cnt_clock name "__inst_name___n_cnt_clk"
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data n_cnt_clock src refclk
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data n_cnt_clock master ""
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data n_cnt_clock multiply_by 1
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data n_cnt_clock divide_by 1
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data n_cnt_clock phase 0.000
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data n_cnt_clock duty_cycle 50
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data m_cnt_clock pattern __inst_name__|tennm_pll~mcntr_reg
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data m_cnt_clock node_type register
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data m_cnt_clock pin_id ""
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data m_cnt_clock pin_node_name ""
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data m_cnt_clock is_valid false
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data m_cnt_clock exists false
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data m_cnt_clock name "__inst_name___m_cnt_clk"
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data m_cnt_clock src refclk
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data m_cnt_clock master ""
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data m_cnt_clock multiply_by 1
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data m_cnt_clock divide_by 10
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data m_cnt_clock phase 0.000
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data m_cnt_clock duty_cycle 50
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk1 pattern __inst_name__|tennm_pll|outclk\[1\]
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk1 node_type pin
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk1 pin_id ""
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk1 pin_node_name ""
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk1 is_valid false
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk1 exists false
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk1 name __inst_name___outclk0
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk1 src refclk
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk1 master ""
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk1 multiply_by 10
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk1 divide_by 20
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk1 phase 0.000
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk1 duty_cycle 50
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk1 counter_index 1
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk2 pattern __inst_name__|tennm_pll|outclk\[2\]
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk2 node_type pin
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk2 pin_id ""
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk2 pin_node_name ""
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk2 is_valid false
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk2 exists false
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk2 name __inst_name___outclk1
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk2 src refclk
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk2 master ""
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk2 multiply_by 10
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk2 divide_by 8
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk2 phase 0.000
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk2 duty_cycle 50
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk2 counter_index 2
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk3 pattern __inst_name__|tennm_pll|outclk\[3\]
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk3 node_type pin
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk3 pin_id ""
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk3 pin_node_name ""
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk3 is_valid false
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk3 exists false
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk3 name __inst_name___outclk2
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk3 src refclk
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk3 master ""
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk3 multiply_by 10
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk3 divide_by 5
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk3 phase 0.000
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk3 duty_cycle 50
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk3 counter_index 3
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk4 pattern __inst_name__|tennm_pll|outclk\[4\]
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk4 node_type pin
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk4 pin_id ""
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk4 pin_node_name ""
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk4 is_valid false
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk4 exists false
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk4 name __inst_name___outclk3
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk4 src refclk
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk4 master ""
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk4 multiply_by 10
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk4 divide_by 8
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk4 phase 90.000
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk4 duty_cycle 50
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk4 counter_index 4
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk5 pattern __inst_name__|tennm_pll|outclk\[5\]
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk5 node_type pin
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk5 pin_id ""
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk5 pin_node_name ""
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk5 is_valid false
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk5 exists false
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk5 name __inst_name___outclk4
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk5 src refclk
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk5 master ""
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk5 multiply_by 10
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk5 divide_by 10
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk5 phase 0.000
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk5 duty_cycle 50
dict set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data outclk5 counter_index 5
 13 0 1 / 4 home 7 mustafa 8 projects 15 cva6_intel_fpga 4 cva6 9 corev_apu 5 intel 2 ip 6 io_pll 17 altera_iopll_1931 5 synth 44 io_pll_altera_iopll_1931_saopfla_pin_map.tcl 42250 # (C) 2001-2024 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file contains the traversal routines that are used by
# io_pll_altera_iopll_1931_saopfla.sdc scripts. 
#
# These routines are only meant to support the SDC. 
# Trying to using them in a different context can have unexpected 
# results.

set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_corename_debug 0

set script_dir [file dirname [info script]]

source [file join $script_dir io_pll_altera_iopll_1931_saopfla_parameters.tcl]

proc get_warnings_disabled {} {
    set local_disable_warnings true
    set inis [split [get_global_assignment -name INI_VARS] ";"]
    foreach ini $inis {
        set ini_lst [split $ini "="]
        lassign $ini_lst ini_name ini_value
        if {$ini_name == "disable_warnings" && $ini_value == "off"} {
            set local_disable_warnings false
            break
        }
    }
    return $local_disable_warnings 
}
set ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_corename_disable_warnings [get_warnings_disabled]

# ----------------------------------------------------------------
#
proc ai_post_message {msg_type msg {msg_context sta_only}} {
#
# Description: Posts a message to Quartus, depending on 
# msg_context (sta_only, all)
#              
#              
#
# ----------------------------------------------------------------

    if {$msg_type == "debug"} {
        if {$::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_corename_debug} {
            puts $msg
        }
    } else {
        if {$msg_context == "all"} {
            post_message -type $msg_type $msg
        } elseif {$msg_context == "sta_only"} {
            if {$::TimeQuestInfo(nameofexecutable) == "quartus_sta"} {
                post_message -type $msg_type $msg
            }
        }
    }
}

# ----------------------------------------------------------------
#
proc ai_are_entity_names_on { } {
#
# Description: Determines if the entity names option is on
#
# ----------------------------------------------------------------
	return [set_project_mode -is_show_entity]	
}

# ----------------------------------------------------------------
#
proc ai_initialize_pll_db { pll_db_par } {
#
# Description: Gets the instances of this particular PLL IP and creates the pin
#              cache
#
# ----------------------------------------------------------------
	upvar $pll_db_par local_pll_db

	global ::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_corename

	ai_post_message info "Initializing PLL database for CORE $::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_corename"
	set instance_list [ai_get_core_instance_list $::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_corename]

	foreach instname $instance_list {
		ai_post_message info "Finding port-to-pin mapping for CORE: $::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_corename INSTANCE: $instname"

		set clock_data_dicts [ai_get_pll_pins $instname]
		lassign $clock_data_dicts base_clock_data_dict gen_clock_data_dict
        print_clock_data $base_clock_data_dict
        print_clock_data $gen_clock_data_dict 

		set local_pll_db($instname) $clock_data_dicts 
	}
}

# ----------------------------------------------------------------
#
proc ai_get_core_instance_list {corename} {
#
# Description: Converts node names from one style to another style
#
# ----------------------------------------------------------------
	set full_instance_list [ai_get_core_full_instance_list $corename]
	set instance_list [list]

	foreach inst $full_instance_list {
		if {[lsearch $instance_list [escape_brackets $inst]] == -1} {
            ai_post_message debug "Found instance:  $inst"
			lappend instance_list $inst
		}
	}
	return $instance_list
}

# ----------------------------------------------------------------
#
proc ai_get_core_full_instance_list {corename} {
#
# Description: Finds the instances of the particular IP by searching through the cells
#
# ----------------------------------------------------------------

	set instance_list [design::get_instances -entity $corename]
                               
	if {[ llength $instance_list ] == 0} {

        if {!$::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_corename_disable_warnings} {
            ai_post_message warning "The auto-constraining script was not able to detect any instance for core < $corename >" all
            ai_post_message warning "Verify the following:"
            ai_post_message warning " The core < $corename > is instantiated within another component (wrapper)" all
            ai_post_message warning " The core is not the top-level of the project" all
        }
	}

	return $instance_list
}
proc ai_get_registers {pattern} {
    if {$::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_corename_disable_warnings} {
        return [get_registers -nowarn -no_duplicates $pattern]
    } else {
        return [get_registers -no_duplicates $pattern]
    }
}
proc ai_get_pins {pattern} {
    if {$::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_corename_disable_warnings} {
        return [get_pins -nowarn -no_duplicates $pattern]
    } else {
        return [get_pins -no_duplicates $pattern]
    }
}
proc ai_get_pin_node_name {pattern} {
    set pin_collection [ai_get_pins $pattern]
    set num_pins [get_collection_size $pin_collection]
    if {$num_pins == 1} {
        foreach_in_collection id $pin_collection {
            set node_name [get_node_info -name $id]	     
            return $node_name
        }
    } 
    return ""
 
}

# ----------------------------------------------------------------
#
proc ai_get_collection_size_from_pattern {pattern} {
#
# Description: Takes a string regex and gets the pin collection.
#
# ----------------------------------------------------------------
    set pin_collection [get_pins -no_duplicates $pattern]
    return [get_collection_size $pin_collection]
}

# ----------------------------------------------------------------
#
proc print_clock_data {d} {
#
# Description: Prints clock data dict
#
# ---------------------------------------------------------------- 
    dict for {clock_key info} $d {
        ai_post_message debug "Clock:  $clock_key"
        dict for {key val} $info {
            ai_post_message debug "   $key: $val"
        }
    }
}

# ----------------------------------------------------------------
#
proc ai_subst_instname {clock_data_dict patt} {
#
# Description: Takes a string regex and gets the pin collection.
#
# ----------------------------------------------------------------
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            regsub -all "__inst_name__" $name $patt new_name
            regsub -all "__inst_name__" $pattern $patt new_pattern
            
            dict set clock_data_dict $clock_key name $new_name
            dict set clock_data_dict $clock_key pattern $new_pattern
            
            if {[dict exists $clock_data_dict $clock_key "through_pin" ]} {
                regsub -all "__inst_name__" $through_pin $patt new_through_pin
                dict set clock_data_dict $clock_key through_pin $new_through_pin
            }
        }
    }
    return $clock_data_dict
}
# ----------------------------------------------------------------
#
proc ai_update_genclk_div_mult {clock_data_dict pll_parameters_dict} {
#
# Description: Updates the dict with div/mult values collected from
# the PLL's atom parameters.
#
# ----------------------------------------------------------------
    set compensated_counter_div 0
    set clock_to_compensate [dict get $pll_parameters_dict clock_to_compensate]
    # Loop over dict to find the compensated counter's div value first.
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            if {[info exists counter_index]} { 
                if {$counter_index == $clock_to_compensate} {
                    set compensated_counter_div [dict get $pll_parameters_dict c${counter_index}_total]
                }
            }
        }
        unset -nocomplain counter_index
    }
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            ai_post_message debug "Getting div/mult factors for clock $clock_key" 

            set ccnt -1
            if {[info exists counter_index]} {
                set ccnt [dict get $pll_parameters_dict c${counter_index}_total]
			    set ccnt_dc [dict get $pll_parameters_dict duty_cycle${counter_index}]
            } else {
                set counter_index -1
			    set ccnt_dc 50
            }
            set mult_div [ai_get_mult_div_factors \
                $clock_key \
                $src \
                [dict get $pll_parameters_dict n_total] \
                [dict get $pll_parameters_dict m_total] \
                $ccnt \
                $counter_index \
                $compensated_counter_div \
                [dict get $pll_parameters_dict compensation_mode] \
                [dict get $pll_parameters_dict clock_to_compensate]]

            lassign $mult_div mult div

            ai_post_message debug "Setting mult_div factors for: $clock_key to $mult/$div"

            dict set clock_data_dict $clock_key multiply_by $mult
            dict set clock_data_dict $clock_key divide_by $div
            dict set clock_data_dict $clock_key duty_cycle $ccnt_dc
        }
        unset -nocomplain counter_index
    }
    return $clock_data_dict
}
# ----------------------------------------------------------------
#
proc ai_set_genclk_pin_info {clock_data_dict} {
#
# Description: Updates the dict with pin info collected from making
# STA API calls.
#
# ----------------------------------------------------------------
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            ai_post_message debug "Setting pin info for clock $clock_key"
            if {$node_type == "register"} {
                set pin_collection [ai_get_registers $pattern]
            } elseif {$node_type == "pin"} {
                set pin_collection [ai_get_pins $pattern]
            } else {
                ai_post_message "debug" "Incorrect type of node."
            }
            set num_pins [get_collection_size $pin_collection]
            if {$num_pins == 1} {
                # Always set valid to true if we found the pin node
                ai_post_message debug "Setting clock as valid."
                dict set clock_data_dict $clock_key is_valid true
                
                # This for loop should only loop once.
                foreach_in_collection id $pin_collection {
                    set node_name [get_node_info -name $id]	     
                    dict set clock_data_dict $clock_key pin_id $id
                    dict set clock_data_dict $clock_key pin_node_name $node_name
                }
                # Check if clock_exists, if it does, then
                # set key "exists" on the clock info dict.
                dict set clock_data_dict $clock_key exists [ai_clock_exists $node_name]

            
            } else {
                dict set clock_data_dict $clock_key is_valid false
            }

        }
    }
    return $clock_data_dict
    
    
} 
# ----------------------------------------------------------------
#
proc ai_set_baseclk_pin_info {clock_data_dict refclk_data_dict pll_name} {
#
    # Description: Updates the dict with pin info collected from refclk data
    # dict, which was obtained by traversing netlist.
#
# ----------------------------------------------------------------
    ai_post_message debug "In ai_set_baseclk_pin_info"

    dict for {clock_key info} $clock_data_dict {
        dict with info {
            ai_post_message debug "Setting pin info for clock $clock_key"
            
            set node_name ""
            dict for {clock_id info} $refclk_data_dict {
                dict with info {
                    # Figure out which refclk is the baseclk based on input muxes 
                    set pll_atom [ai_get_pll_atom $pll_name]
                    set clkin_enum "ENUM_IOPLL_CLKIN_0_SRC"
                    if {!$is_main_refclk} {
                        set clkin_enum "ENUM_IOPLL_CLKIN_1_SRC"
                    }
                    set refclk_src [get_atom_node_info -key $clkin_enum -node $pll_atom]

                    set refclk_port_name "$pattern"
                    if {[regexp {[0-9]+} $refclk_src refclk_index]} {
                        set refclk_port_name "$pattern\[$refclk_index\]"
                    } 
                    if {[string equal -nocase $refclk_port_name $ref_pin_node_name]} {
                        dict set clock_data_dict $clock_key pin_id $ref_pin_id
                        dict set clock_data_dict $clock_key pin_node_name $ref_pin_node_name
                        dict set clock_data_dict $clock_key port_id $ref_port_id
                        dict set clock_data_dict $clock_key port_node_name $ref_port_node_name
                        dict set clock_data_dict $clock_key is_fpga_pin $ref_is_fpga_pin
                        set node_name $ref_port_node_name
                        break
                    }
                }
            }
            # Check if clock_exists, if it does, then
            # set key "exists" on the clock info dict.
            dict set clock_data_dict $clock_key exists [ai_clock_exists $node_name]

        }
    }
    return $clock_data_dict
    
}
proc ai_get_n_cnt_clock_node_name {gen_clock_data_dict} {
    dict for {clock_key info} $gen_clock_data_dict {
        dict with info {
            ai_post_message debug "Clock:  $clock_key, pin_node_name: $pin_node_name"

            if {$clock_key == "n_cnt_clock"} {
                return $pin_node_name
            }
        }
    }
    return ""
}

# ----------------------------------------------------------------
#
proc ai_update_baseclk_data {base_clock_data_dict pll_parameters_dict} {
#
    # Description: Updates the refclk information based on atom settings
#
# ----------------------------------------------------------------
    ai_post_message debug "In ai_update_baseclk_data_dict"

    dict for {base_clock_key info} $base_clock_data_dict {
        dict with info {
            if {$is_main_refclk} {
                set ref_period [dict get $pll_parameters_dict refclk_period]
                set ref_period [expr round($ref_period * 1000.0)/1000.0] 
                set ref_period [format %.3f $ref_period]
                dict set base_clock_data_dict $base_clock_key period $ref_period

                set half_period [expr $ref_period /2]
                set half_period [expr round($half_period * 1000.0)/1000.0] 
                set half_period [format %.3f $half_period]
                dict set base_clock_data_dict $base_clock_key half_period $half_period
            }
        }
    }

    return $base_clock_data_dict
}

# ----------------------------------------------------------------
#
proc ai_update_genclk_sources {base_clock_data_dict gen_clock_data_dict pll_parameters_dict} {
#
# Description: Updates the genclk data dict with src nodes from the appropriate
#              refclks
#
# ----------------------------------------------------------------
    ai_post_message debug "In ai_update_genclk_sources"

    # Check if vcoph pin exists, if it does then set the clock source
    # as vcoph otherwise set it to either refclk or n_cnt_clock
    set vcoph_exists false
    if {[dict exists $gen_clock_data_dict vcoph]} {
        set vcoph_pin_name [ai_get_pin_node_name [dict get $gen_clock_data_dict vcoph pattern]]
        if {$vcoph_pin_name != ""} {
            ai_post_message debug "vcoph pin name: $vcoph_pin_name "
            set vcoph_exists true
        }
    }

    dict for {clock_key info} $gen_clock_data_dict {
        dict with info {
            ai_post_message debug "Setting src pin info for clock $clock_key"

            set node_name ""
            set main_refclk_key ""
            dict for {base_clock_key base_clock_data_dict_info} $base_clock_data_dict {
                dict with base_clock_data_dict_info {
                    if {$is_main_refclk} {
                        set main_refclk_key $base_clock_key
                        if {$is_fpga_pin} {
                            set node_name $port_node_name
                        } else {
                            set node_name $pin_node_name
                        }
                        break
                    }
                }
            }
            if {$clock_key != "n_cnt_clock" && ![dict get $pll_parameters_dict n_bypass]} {
                set src "n_cnt_clock"
            }

            if {$src == "refclk" || $src == "cascade_in" || $src == "pll_cascade_in" || $src == "core_refclk"} {
                set src_ $node_name
            } elseif {$src == "n_cnt_clock"} {
                if {[is_post_syn_sta]} {
                    set gen_clock_data_dict_for_post_syn $gen_clock_data_dict
                    dict for {clk_key gen_clock_data_dict_for_post_syn_info} $gen_clock_data_dict_for_post_syn {
                        if {$clk_key == "n_cnt_clock"} {
                            dict set gen_clock_data_dict $clock_key master [dict get $gen_clock_data_dict_for_post_syn_info name]
                        }
                    }
                } else {
                    set src_ [ai_get_n_cnt_clock_node_name $gen_clock_data_dict]
                }
            } else {
                set src_ ""
                ai_post_message "warning" "Undefined clock source: $src"
                dict set gen_clock_data_dict $clock_key is_valid false
            }

            if {$clock_key != "n_cnt_clock" && $clock_key != "vcoph" && $vcoph_exists} {
                set src_ $vcoph_pin_name
            }
            dict set gen_clock_data_dict $clock_key src $src_
        }
    }
    return $gen_clock_data_dict
}
proc ai_invalidate_clocks {clock_data_dict} {
    # Set the is_valid flag on each clock to false
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            dict set clock_data_dict $clock_key is_valid false
        }
    }
    return $clock_data_dict
}
proc ai_get_first_outclk_node {clock_data_dict} {
    set outclk_pin_id "None"
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            if {$node_type == "pin" && $is_valid} {
                set outclk_pin_id $pin_id
                break
            }
        }
    }
    if {$outclk_pin_id == "None"} {
        ai_post_message "warning" "Could not find any valid outclks"
    }
    return $outclk_pin_id 
}
# ----------------------------------------------------------------
#
proc ai_get_pll_pins { instname } {
#
# Description: Stores the pins of interest for the instance of the IP
#
# ----------------------------------------------------------------

    set base_clock_data_dict $::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_base_clock_data
    set gen_clock_data_dict $::GLOBAL_top_io_pll_altera_iopll_1931_saopfla_gen_clock_data
    # First regsub the instance name for the pin names and patterns.
    set base_clock_data_dict [ai_subst_instname $base_clock_data_dict $instname]
    set gen_clock_data_dict [ai_subst_instname $gen_clock_data_dict $instname]


    set pll_parameters_dict [ai_get_pll_atom_parameters $instname] 
    set gen_clock_data_dict [ai_set_genclk_pin_info $gen_clock_data_dict]

    ai_post_message debug "gen_clock_data_dict initial: "
    print_clock_data $gen_clock_data_dict 
    
    # Traverse the first generated clock back to find FPGA pins for refclks.
    set outclk_node_id [ai_get_first_outclk_node $gen_clock_data_dict]
    if {$outclk_node_id != "None"} {
        set refclk_data_dict [ai_get_input_clk_info $outclk_node_id]
        ai_post_message debug "refclk_data_dict: "
        print_clock_data $refclk_data_dict

        set base_clock_data_dict [ai_set_baseclk_pin_info $base_clock_data_dict $refclk_data_dict $instname]
        set gen_clock_data_dict [ai_update_genclk_sources $base_clock_data_dict $gen_clock_data_dict $pll_parameters_dict]
        set gen_clock_data_dict [ai_update_genclk_div_mult $gen_clock_data_dict $pll_parameters_dict] 
        set base_clock_data_dict [ai_update_baseclk_data $base_clock_data_dict $pll_parameters_dict] 
        ai_post_message debug "base_clock_data_dict: "
        print_clock_data $base_clock_data_dict 
        ai_post_message debug "gen_clock_data_dict final: "
        print_clock_data $gen_clock_data_dict
    } else {
        # Make sure that we don't create any clock constraints
        # if no output clock was found
        set gen_clock_data_dict [ai_invalidate_clocks $gen_clock_data_dict]
    }
    
    return [list $base_clock_data_dict $gen_clock_data_dict]
    
}

# ----------------------------------------------------------------
#
proc ai_get_input_clk_info { outclk_pin_id } {
#
# Description: Searches back from the output of the PLL to find the reference clock pin.
#              If the reference clock is fed by an input buffer, it finds that pin, otherwise
#              in cascading modes it will return the immediate reference clock input of the PLL.
#
# ----------------------------------------------------------------
	if {[ai_is_node_type_pll_clk $outclk_pin_id]} {
        #stores the refclk pin ids that were found by tracing the 
        #output clocks back up
		array set refclk_array [list]
		ai_traverse_fanin_up_to_depth $outclk_pin_id ai_is_node_type_pll_inclk clock refclk_array 20
        array set refclk_info_array [list]
        foreach {net_id id} [array get refclk_array] {
            set net_name [get_node_info -name $net_id]
            set refclk_info_array($net_id) $net_name

        }
        # Dict to hold the refclk info found by traversing the netlist back.
        # refclk_data = {
        #   clock_id = {
        #       ref_pin_id: str,
        #       ref_pin_node_name: str,
        #       ref_port_id: str,
        #       ref_port_node_name: str,
        #       ref_is_fpga_pin: true/false,
        #   }
        # }
        set refclk_data [dict create]
        
        set clock_id 0

        #only works if there is either 1 or 2 refclks
		if {[array size refclk_array] == 1 || [array size refclk_array] == 2} {
            #iterate over each refclk pin and trace back to find its input port
            foreach refclk_pin_id [array names refclk_info_array] {
                array set user_refclk_array [list]
                array unset refclk_array
                array unset user_refclk_array [list]
					 
                ai_traverse_fanin_up_to_depth $refclk_pin_id ai_is_node_type_user_clock clock user_refclk_array 5
                ai_traverse_fanin_up_to_depth $refclk_pin_id ai_is_node_type_pin clock refclk_array 5
					 
                # If fed by any user specified clock (which could be specified at the pin level or at the
                # buffer level), then use that pin as the source.
                # Otherwise, trace back to the dedicated input pin (depth 5 so that we don't include global clocks)
                if {[array size user_refclk_array] == 1 || [array size refclk_array] < 1} {
                    # Fed by a user specified clock, a global clock etc. 
                    dict set refclk_data $clock_id ref_pin_id $refclk_pin_id 
                    dict set refclk_data $clock_id ref_pin_node_name $refclk_info_array($refclk_pin_id)
                    dict set refclk_data $clock_id ref_port_id ""
                    dict set refclk_data $clock_id ref_port_node_name ""
                    dict set refclk_data $clock_id ref_is_fpga_pin false
                } else {
                    # Fed by a dedicated input pin
                    set port_id_ [lindex [array names refclk_array] 0]

                    dict set refclk_data $clock_id ref_pin_id $refclk_pin_id 
                    dict set refclk_data $clock_id ref_pin_node_name $refclk_info_array($refclk_pin_id)
                    dict set refclk_data $clock_id ref_port_id $port_id_
                    dict set refclk_data $clock_id ref_port_node_name [get_node_info -name $port_id_]
                    dict set refclk_data $clock_id ref_is_fpga_pin true
                }

                incr clock_id
            }
        } else {
			ai_post_message critical_warning "Could not find PLL ref clock that feeds [get_node_info -name $outclk_pin_id]" all
		}
	} else {
		ai_post_message error "Internal error: ai_get_input_clk_info only works for PLL output clocks" all
	}
	return $refclk_data
}

# ----------------------------------------------------------------
#
proc ai_is_node_type_pin { node_id } {
#
# Description: Determines if a node is a top-level port of the FPGA
#
# ----------------------------------------------------------------

	set node_type [get_node_info -type $node_id]
	if {$node_type == "port"} {
		set result 1
	} else {
		set result 0
	}
	return $result
}

# ----------------------------------------------------------------
#
proc ai_is_node_type_user_clock { node_id } {
#
# Description: Determines if a node is a user-defined clock
#
# ----------------------------------------------------------------
    set node_name [get_node_info -name $node_id]	 
   
    if {[ai_clock_exists $node_name]} {
        return 1
    } else {
        return 0
    }
}

# ----------------------------------------------------------------
#
proc ai_is_node_type_pll_clk { node_id } {
#
# Description: Determines if a node is an output of a PLL
#
# ----------------------------------------------------------------

	set cell_id [get_node_info -cell $node_id]
	
	if {$cell_id == ""} {
		set result 0
	} else {
		set atom_type [get_cell_info -atom_type $cell_id]
		if {$atom_type == "IOPLL"} {
			set node_name [get_node_info -name $node_id]
            ai_post_message debug "Node_name: $node_name"
			if {[string match "*fourteennm_pll\|outclk\\\[*\\\]" $node_name]||[string match "*tennm_pll\|outclk\\\[*\\\]" $node_name]} {
				set result 1
			} elseif {[string match "*fourteennm_pll~ncntr_reg" $node_name]||[string match "*tennm_pll~ncntr_reg" $node_name]} {
				set result 1				
			} elseif {[string match "*fourteennm_pll~c*cntr_reg" $node_name]||[string match "*tennm_pll~c*cntr_reg" $node_name]} {
				set result 1				
			} elseif {[string match "*fourteennm_pll~mcntr_reg" $node_name]||[string match "*tennm_pll~mcntr_reg" $node_name]} {
				set result 1				
			} elseif {[string match "*fourteennm_pll\|lvds_clk\\\[*\\\]" $node_name]||[string match "*tennm_pll\|lvds_clk\\\[*\\\]" $node_name]} {
				set result 1				
			} elseif {[string match "*fourteennm_pll\|loaden\\\[*\\\]" $node_name]||[string match "*tennm_pll\|loaden\\\[*\\\]" $node_name]} {
				set result 1
			} elseif {[string match "*fourteennm_pll\|vcoph\\\[*\\\]" $node_name]||[string match "*tennm_pll\|vcoph\\\[*\\\]" $node_name]} {
				set result 1
			} elseif {[string match "*fourteennm_pll\|pll_cascade_out" $node_name]||[string match "*tennm_pll\|pll_cascade_out" $node_name]} {
				set result 1
			} elseif {[string match "*fourteennm_pll\|extclk_output\\\[*\\\]" $node_name]||[string match "*tennm_pll\|extclk_output\\\[*\\\]" $node_name]} {
				set result 1
			} else {
				set result 0
			}
		} else {
			set result 0
		}
	}
	return $result
}

# ----------------------------------------------------------------
#
proc ai_is_node_type_pll_inclk { node_id } {
#
# Description: Determines if a node is an input of a PLL
#
# ----------------------------------------------------------------


	set cell_id [get_node_info -cell $node_id]
	
	if {$cell_id == ""} {
		set result 0
	} else {
		set atom_type [get_cell_info -atom_type $cell_id]
		if {$atom_type == "IOPLL"} {
			set node_name [get_node_info -name $node_id]
			set fanin_edges [get_node_info -clock_edges $node_id]
			if {([string match "*|refclk\\\[*\\\]" $node_name]) && [llength $fanin_edges] > 0} {
				set result 1
            } elseif {([string match "*|pll_cascade_in" $node_name]) && [llength $fanin_edges] > 0} {
				set result 1
            } elseif {([string match "*|cascade_in" $node_name]) && [llength $fanin_edges] > 0} {
				set result 1
            } elseif {([string match "*|core_refclk" $node_name]) && [llength $fanin_edges] > 0} {
				set result 1
			} else {
				set result 0
			}
		} else {
			set result 0
		}
	}
	return $result
}

# -----------------------------------------------------------------
#
proc ai_find_pll_inclk { match_command edge_type } {
#
# Desciption: Finds the pll inclk pin whose name matches the
#             match_command. Returns the inclk pin name if such
#             a pin is found, and returns "" if it is not found
#
# -----------------------------------------------------------------

    set fanin_id ""
    foreach_in_collection pin [get_pins $match_command] {
        if {[llength [get_node_info -${edge_type}_edges $pin]] > 0} {
            set fanin_id $pin
            break
        }
    }
    return $fanin_id
}

# ----------------------------------------------------------------
#
proc ai_traverse_fanin_up_to_depth { node_id match_command edge_type results_array_name depth} {
#
# Description: General traversal function up until a depth.  Use a function pointer to decide
#              ending conditions.
#
# ----------------------------------------------------------------

	upvar 1 $results_array_name results

	if {$depth < 0} {
		error "Internal error: Bad timing netlist search depth"
	}

	ai_post_message debug "\[ai_traverse_fanin_up_to_depth\] called with node_id: $node_id cmd: \"$match_command\" type: $edge_type node: [get_node_info -name $node_id]"
	if {[is_post_syn_sta] && $match_command == "ai_is_node_type_pll_inclk"} {
		set atom_name [get_cell_info -name [get_node_info -cell $node_id]]
        set fanin_id [ai_find_pll_inclk $atom_name|core*refclk* $edge_type]
        if {$fanin_id == ""} {
            set fanin_id [ai_find_pll_inclk $atom_name|pll*cascade*in* $edge_type]
        }
        if {$fanin_id == ""} {
            set fanin_id [ai_find_pll_inclk $atom_name|ref*clk* $edge_type]
        }
		set results($fanin_id) 1
		ai_post_message debug "\[ai_traverse_fanin_up_to_depth\] post syn model returning fanin id: [get_node_info -name $fanin_id]"
		return
	}

	set fanin_edges [get_node_info -${edge_type}_edges $node_id]
	set number_of_fanin_edges [llength $fanin_edges]
	for {set i 0} {$i != $number_of_fanin_edges} {incr i} {
		set fanin_edge [lindex $fanin_edges $i]
		set fanin_id [get_edge_info -src $fanin_edge]
		if {$match_command == "" || [eval $match_command $fanin_id] != 0} {
			set results($fanin_id) 1
		} elseif {$depth == 0} {
		} else {
			ai_traverse_fanin_up_to_depth $fanin_id $match_command $edge_type results [expr {$depth - 1}]
		}
	}
}

# ----------------------------------------------------------------
#
proc ai_index_in_collection { col j } {
#
# Description: Returns a particular index in a collection.
#              Analagous to lindex for lists.
#
# ----------------------------------------------------------------

	set i 0
	foreach_in_collection path $col {
		if {$i == $j} {
			return $path
		}
		set i [expr $i + 1]
	}
	return ""
}

#
# Description: Rounds a given floating point number
#              to 3 decimal places
#
# ----------------------------------------------------------------
proc ai_round_3dp { x } {
    return [expr { round($x * 1000) / 1000.0  } ]
}

# ----------------------------------------------------------------
# Description: Checks whether a given clock already exists 
# ----------------------------------------------------------------
proc ai_clock_exists { clock_name } {
    set clock_found false
    set input_clocks_col [get_clocks -nowarn]
    set num_input_clocks [get_collection_size $input_clocks_col]
    
    if {$num_input_clocks > 0} {
        foreach_in_collection iclk $input_clocks_col {
            if {![is_clock_defined $iclk]} {
                continue
            }

            set clk_targets_col [get_clock_info -target $iclk]
            set num_clk_targets [get_collection_size $clk_targets_col]
            if {$num_clk_targets > 0} {
                foreach_in_collection itgt $clk_targets_col {
                    set node_name [get_node_info -name $itgt]
                    if {[string compare $node_name $clock_name] == 0} {
                        set clock_found true
                        break
                    }
                }
            }
            if {$clock_found == true} {
                break;
            }
        }
    }

   return $clock_found 
}

proc ai_get_pll_atom {instname} {
    foreach_in_collection node [get_atom_nodes -type IOPLL] {
        set name [get_atom_node_info -key NAME -node $node]
        set node_list($name) $node

        if {[string first $instname $name] > -1} {
            return $node
        }
    }
    set sdc_file_name [info script]
    ai_post_message warning "Could not find IOPLL atom with the name <$instname> while processing <$sdc_file_name>. Please check the synthesis report to ensure that the IOPLL was not synthesized away." all
}
proc ai_get_mult_div_factors {clock_key src ncnt mcnt ccnt counter_index \
                              compensated_counter_div compensation_mode \
                              clock_to_compensate} {
    if {$clock_key == "vcoph"} {
        set clock_mult $mcnt
        set clock_div 1
    } elseif {$clock_key == "n_cnt_clock"} {
        set clock_mult 1
        set clock_div $ncnt
    } elseif {$clock_key == "m_cnt_clock"} {
        set clock_mult 1
        set clock_div [expr {$mcnt * $ncnt}]
    } else {

        if {[string first "vcoph" $src] > -1} {
            set clock_mult 1
            set clock_div $ccnt
        } else {
            # Handle NDFB mode. 
            # The equation for counter which is to be compensated: C_k = M / N
            # The equation for all other counters:                 C_!k = (M * C_k) / (N * C_!k)
            if {$compensation_mode == "NON_DEDICATED_SOURCE_SYNC" || $compensation_mode == "NON_DEDICATED_NORMAL"} {
                if {$counter_index == $clock_to_compensate} {
                    set clock_mult $mcnt
                    # Instead of dividing by N, we just divide by 1
                    # since a clock based on the N counter would be created
                    # if N > 1 and this clock would be derived based on that,
                    # so we already have a division happening.
                    set clock_div 1
                } else {
                    set clock_mult [expr $mcnt * $compensated_counter_div]
                    set clock_div $ccnt
                }
            } else {
                ai_post_message debug "Normal C counter"
                set clock_mult $mcnt
                set clock_div $ccnt
            }
        }
    }
    return [list $clock_mult $clock_div]

}
# ----------------------------------------------------------------
#
proc ai_get_pll_atom_parameters {instname} {
#
# Description: Gets the PLL paramaters from the Quartus atom and not 
#              from the IP generated parameters.
#
# ----------------------------------------------------------------

    set pll_atom [ai_get_pll_atom $instname]
																			 
	dict set pll_params compensation_mode [get_atom_node_info -key ENUM_IOPLL_FEEDBACK -node $pll_atom]
	dict set pll_params clock_to_compensate [get_atom_node_info -key INT_IOPLL_CLOCK_TO_COMPENSATE -node $pll_atom]

    # Get refclk frequency (might have changed since IP generation)
    set refclk_freq [get_atom_node_info -key TIME_IOPLL_REFCLK_TIME -node $pll_atom]
    set refclk_int [string trim $refclk_freq "*MHZmhz"]
    set refclk_period [expr 1000.0 / $refclk_int]
    dict set pll_params refclk_period $refclk_period

	dict set pll_params m_hi_div [get_atom_node_info -key INT_IOPLL_M_COUNTER_HIGH -node $pll_atom]
	dict set pll_params m_lo_div [get_atom_node_info -key INT_IOPLL_M_COUNTER_LOW -node $pll_atom]
	dict set pll_params m_bypass [get_atom_node_info -key BOOL_IOPLL_M_COUNTER_BYPASS_EN -node $pll_atom]
    if {[dict get $pll_params m_bypass]} {
        set total 1
    } else {
        set total  [expr [dict get $pll_params m_hi_div] + [dict get $pll_params m_lo_div]]
    }
	dict set pll_params m_total $total

	dict set pll_params n_hi_div [get_atom_node_info -key INT_IOPLL_N_COUNTER_HIGH -node $pll_atom]
	dict set pll_params n_lo_div [get_atom_node_info -key INT_IOPLL_N_COUNTER_LOW -node $pll_atom]
	dict set pll_params n_bypass [get_atom_node_info -key BOOL_IOPLL_N_COUNTER_BYPASS_EN -node $pll_atom]
    if {[dict get $pll_params n_bypass]} {
        set total 1
    } else {
        set total  [expr [dict get $pll_params n_hi_div] + [dict get $pll_params n_lo_div]]
    }
	dict set pll_params n_total $total

	for { set i 0 } { $i < 9} { incr i } {
        # Get the C counter parameter settings from the atom netlist
        dict set pll_params c${i}_hi_div [get_atom_node_info -key INT_IOPLL_C${i}_HIGH -node $pll_atom]
        dict set pll_params c${i}_lo_div [get_atom_node_info -key INT_IOPLL_C${i}_LOW -node $pll_atom]
        dict set pll_params c${i}_bypass [get_atom_node_info -key BOOL_IOPLL_C${i}_BYPASS_EN -node $pll_atom]
        dict set pll_params c${i}_odd_div_duty_en [get_atom_node_info -key BOOL_IOPLL_C${i}_EVEN_DUTY_EN -node $pll_atom]

        # Calculate the total counter value
        if {[dict get $pll_params c${i}_bypass]} {
            set total 1
        } else {
            set total [expr [dict get $pll_params c${i}_hi_div] + [dict get $pll_params c${i}_lo_div]]
        }
        dict set pll_params c${i}_total $total

        # Calculate the duty cycle
        if {[dict get $pll_params c${i}_bypass]} {
            set total_duty 50
        } else {
            if {[dict get $pll_params c${i}_odd_div_duty_en]} {
                set duty_tweak 1
            } else {
                set duty_tweak 0
            }
            set total_duty [expr (([dict get $pll_params c${i}_hi_div] - (0.5*$duty_tweak))*100)/$total]
		    set total_duty [format %.3f $total_duty]
        }
        dict set pll_params duty_cycle${i} $total_duty
    }

    return $pll_params
}

#__ACDS_USER_COMMENT__Set max delay if in fit flow, otherwise set false path through "through_pin"
# originally in the LVDS SDC. This is called if we are exporting loaden to LVDS
proc set_max_delay_in_fit_or_false_path_in_sta_through_no_warn {through_pin delay} {

    set through_pin_collection [get_pins -compatibility_mode -nowarn $through_pin]
    if {[get_collection_size $through_pin_collection] <= 0} { return }
    
    # if fit_flow == 1
    if {$::TimeQuestInfo(nameofexecutable) == "quartus_fit" } { 
        set_max_delay -through $through_pin_collection $delay
    } else { 
        set_false_path -through $through_pin_collection
    } 
} 

# ----------------------------------------------------------------
#
proc is_m_n_cntr {pattern} {
#
# Description: Determines if a pattern matches m/n_cntr
#
# ----------------------------------------------------------------

    if {[string match "*fourteennm_pll~ncntr_reg" $pattern]||[string match "*tennm_pll~ncntr_reg" $pattern]||
        [string match "*fourteennm_pll~mcntr_reg" $pattern]||[string match "*tennm_pll~mcntr_reg" $pattern]||
        [string match "*tennm_ph2_iopll~ncntr_reg" $pattern]||[string match "*tennm_ph2_iopll~mcntr_reg" $pattern]} {
            return 1
    } else {
        return 0
    }
}

# ----------------------------------------------------------------
#
proc create_non_virtual_generated_clock_with_master_or_source \
{master source name multiply_by divide_by phase duty_cycle pin_node_name} {
#
# Description: Creates a non-virtual generated clock using
#              the -source or the -master argument
#
# ----------------------------------------------------------------
    if {$master != ""} {
        create_generated_clock -add \
            -master $master \
            -name $name \
            -multiply_by $multiply_by \
            -divide_by $divide_by \
            -phase $phase \
            -duty_cycle $duty_cycle \
            $pin_node_name
    } else {
        create_generated_clock -add \
            -source $source \
            -name $name \
            -multiply_by $multiply_by \
            -divide_by $divide_by \
            -phase $phase \
            -duty_cycle $duty_cycle \
            $pin_node_name
    }
}

# ----------------------------------------------------------------
#
proc create_virtual_generated_clock_with_master_or_source \
{master source name multiply_by divide_by phase duty_cycle} {
#
# Description: Creates a virtual generated clock using
#              the -source or the -master argument
#
# ----------------------------------------------------------------
    if {$master != ""} {
        create_generated_clock -add \
            -master $master \
            -name $name \
            -multiply_by $multiply_by \
            -divide_by $divide_by \
            -phase $phase \
            -duty_cycle $duty_cycle
    } else {
        create_generated_clock -add \
            -source $source \
            -name $name \
            -multiply_by $multiply_by \
            -divide_by $divide_by \
            -phase $phase \
            -duty_cycle $duty_cycle
    }
}
 0
